CCS PCM C Compiler, Version 5.074, 32906               02-เม.ย.-20 01:45

               Filename:   D:\Ronnachai\CPE Couse\261214 Microprocessor and Interfacing\game\2048\main.lst

               ROM used:   1975 words (24%)
                           Largest free fragment is 2048
               RAM used:   67 (18%) at main() level
                           79 (21%) worst case
               Stack used: 0 locations
               Stack size: 8

*
0000:  MOVLW  03
0001:  MOVWF  0A
0002:  GOTO   398
0003:  NOP
.................... #include <16F886.h> 
.................... //////////// Standard Header file for the PIC16F886 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC16F886 
0004:  DATA 89,04
0005:  DATA 3C,10
0006:  DATA D7,32
0007:  DATA EC,31
0008:  DATA EF,36
0009:  DATA 65,10
000A:  DATA F4,37
000B:  DATA 20,19
000C:  DATA 30,1A
000D:  DATA 38,10
000E:  DATA E7,30
000F:  DATA ED,32
0010:  DATA 20,1F
0011:  DATA 0D,05
0012:  DATA 00,00
0013:  DATA A7,30
0014:  DATA 27,10
0015:  DATA 3D,10
0016:  DATA CC,32
0017:  DATA 66,3A
0018:  DATA 20,10
0019:  DATA 27,32
001A:  DATA 27,10
001B:  DATA 3D,10
001C:  DATA D2,34
001D:  DATA 67,34
001E:  DATA 74,10
001F:  DATA A0,13
0020:  DATA F7,13
0021:  DATA A0,1E
0022:  DATA A0,2A
0023:  DATA 70,10
0024:  DATA A0,13
0025:  DATA F3,13
0026:  DATA A0,1E
0027:  DATA 20,22
0028:  DATA EF,3B
0029:  DATA EE,06
002A:  DATA 0A,05
002B:  DATA 00,01
002C:  DATA 8C,2C
002D:  DATA EF,3A
002E:  DATA 72,10
002F:  DATA F3,31
0030:  DATA 6F,39
0031:  DATA 65,05
0032:  DATA A5,3A
0033:  DATA 00,00
0034:  DATA 89,04
0035:  DATA 89,10
0036:  DATA C7,30
0037:  DATA ED,32
0038:  DATA A0,27
0039:  DATA F6,32
003A:  DATA F2,10
003B:  DATA 0D,05
003C:  DATA 00,01
003D:  DATA 89,04
003E:  DATA 61,32
003F:  DATA 64,10
0040:  DATA EE,32
0041:  DATA 77,10
0042:  DATA 5B,19
0043:  DATA 5D,10
0044:  DATA 69,37
0045:  DATA 20,14
0046:  DATA 25,32
0047:  DATA AC,12
0048:  DATA E4,14
0049:  DATA 0D,05
004A:  DATA 00,00
004B:  DATA 89,04
004C:  DATA 89,16
004D:  DATA AD,16
004E:  DATA 2D,26
004F:  DATA 65,33
0050:  DATA F4,16
0051:  DATA AD,16
0052:  DATA AD,06
0053:  DATA 0A,00
0054:  DATA 89,04
0055:  DATA 89,16
0056:  DATA AD,16
0057:  DATA D2,34
0058:  DATA 67,34
0059:  DATA F4,16
005A:  DATA AD,16
005B:  DATA 0D,05
005C:  DATA 00,01
005D:  DATA 89,04
005E:  DATA 89,16
005F:  DATA AD,16
0060:  DATA 2D,2A
0061:  DATA 6F,38
0062:  DATA AD,16
0063:  DATA AD,16
0064:  DATA 0D,05
0065:  DATA 00,01
0066:  DATA 89,04
0067:  DATA 89,16
0068:  DATA AD,16
0069:  DATA C2,37
006A:  DATA 74,3A
006B:  DATA EF,36
006C:  DATA AD,16
006D:  DATA AD,06
006E:  DATA 0A,00
*
0182:  MOVF   0B,W
0183:  MOVWF  5B
0184:  BCF    0B.7
0185:  BSF    03.5
0186:  BSF    03.6
0187:  BSF    0C.7
0188:  BSF    0C.0
0189:  NOP
018A:  NOP
018B:  BCF    03.5
018C:  BCF    03.6
018D:  BTFSC  5B.7
018E:  BSF    0B.7
018F:  BSF    03.6
0190:  MOVF   0C,W
0191:  ANDLW  7F
0192:  BTFSC  03.2
0193:  GOTO   1D8
0194:  BCF    03.6
0195:  MOVWF  5B
0196:  BSF    03.6
0197:  MOVF   0D,W
0198:  BCF    03.6
0199:  MOVWF  5C
019A:  BSF    03.6
019B:  MOVF   0F,W
019C:  BCF    03.6
019D:  MOVWF  5D
019E:  MOVF   5B,W
019F:  BTFSS  0C.4
01A0:  GOTO   19F
01A1:  MOVWF  19
01A2:  MOVF   5C,W
01A3:  BSF    03.6
01A4:  MOVWF  0D
01A5:  BCF    03.6
01A6:  MOVF   5D,W
01A7:  BSF    03.6
01A8:  MOVWF  0F
01A9:  BCF    03.6
01AA:  MOVF   0B,W
01AB:  MOVWF  5E
01AC:  BCF    0B.7
01AD:  BSF    03.5
01AE:  BSF    03.6
01AF:  BSF    0C.7
01B0:  BSF    0C.0
01B1:  NOP
01B2:  NOP
01B3:  BCF    03.5
01B4:  BCF    03.6
01B5:  BTFSC  5E.7
01B6:  BSF    0B.7
01B7:  BSF    03.6
01B8:  RLF    0C,W
01B9:  RLF    0E,W
01BA:  ANDLW  7F
01BB:  BTFSC  03.2
01BC:  GOTO   1D8
01BD:  BCF    03.6
01BE:  MOVWF  5B
01BF:  BSF    03.6
01C0:  MOVF   0D,W
01C1:  BCF    03.6
01C2:  MOVWF  5C
01C3:  BSF    03.6
01C4:  MOVF   0F,W
01C5:  BCF    03.6
01C6:  MOVWF  5D
01C7:  MOVF   5B,W
01C8:  BTFSS  0C.4
01C9:  GOTO   1C8
01CA:  MOVWF  19
01CB:  MOVF   5C,W
01CC:  BSF    03.6
01CD:  MOVWF  0D
01CE:  BCF    03.6
01CF:  MOVF   5D,W
01D0:  BSF    03.6
01D1:  MOVWF  0F
01D2:  INCF   0D,F
01D3:  BTFSC  03.2
01D4:  INCF   0F,F
01D5:  BCF    03.6
01D6:  GOTO   182
01D7:  BSF    03.6
01D8:  BCF    03.6
01D9:  RETURN
*
0218:  MOVF   0B,W
0219:  MOVWF  5C
021A:  BCF    0B.7
021B:  BSF    03.5
021C:  BSF    03.6
021D:  BSF    0C.7
021E:  BSF    0C.0
021F:  NOP
0220:  NOP
0221:  BCF    03.5
0222:  BCF    03.6
0223:  BTFSC  5C.7
0224:  BSF    0B.7
0225:  BTFSC  03.0
0226:  GOTO   24F
0227:  BSF    03.6
0228:  MOVF   0C,W
0229:  ANDLW  7F
022A:  BCF    03.6
022B:  MOVWF  5C
022C:  BSF    03.6
022D:  MOVF   0D,W
022E:  BCF    03.6
022F:  MOVWF  5D
0230:  BSF    03.6
0231:  MOVF   0F,W
0232:  BCF    03.6
0233:  MOVWF  5E
0234:  MOVF   5C,W
0235:  MOVWF  5F
0236:  CALL   1EC
0237:  MOVF   5D,W
0238:  BSF    03.6
0239:  MOVWF  0D
023A:  BCF    03.6
023B:  MOVF   5E,W
023C:  BSF    03.6
023D:  MOVWF  0F
023E:  BCF    03.6
023F:  MOVF   0B,W
0240:  MOVWF  5F
0241:  BCF    0B.7
0242:  BSF    03.5
0243:  BSF    03.6
0244:  BSF    0C.7
0245:  BSF    0C.0
0246:  NOP
0247:  NOP
0248:  BCF    03.5
0249:  BCF    03.6
024A:  BTFSC  5F.7
024B:  BSF    0B.7
024C:  DECFSZ 5B,F
024D:  GOTO   24F
024E:  GOTO   26E
024F:  BSF    03.6
0250:  RLF    0C,W
0251:  RLF    0E,W
0252:  ANDLW  7F
0253:  BCF    03.6
0254:  MOVWF  5C
0255:  BSF    03.6
0256:  MOVF   0D,W
0257:  BCF    03.6
0258:  MOVWF  5D
0259:  BSF    03.6
025A:  MOVF   0F,W
025B:  BCF    03.6
025C:  MOVWF  5E
025D:  MOVF   5C,W
025E:  MOVWF  5F
025F:  CALL   1EC
0260:  MOVF   5D,W
0261:  BSF    03.6
0262:  MOVWF  0D
0263:  BCF    03.6
0264:  MOVF   5E,W
0265:  BSF    03.6
0266:  MOVWF  0F
0267:  INCF   0D,F
0268:  BTFSC  03.2
0269:  INCF   0F,F
026A:  BCF    03.0
026B:  BCF    03.6
026C:  DECFSZ 5B,F
026D:  GOTO   218
026E:  BCF    0A.3
026F:  BCF    0A.4
0270:  GOTO   41C (RETURN)
0271:  MOVF   64,W
0272:  CLRF   78
0273:  SUBWF  63,W
0274:  BTFSC  03.0
0275:  GOTO   279
0276:  MOVF   63,W
0277:  MOVWF  77
0278:  GOTO   285
0279:  CLRF   77
027A:  MOVLW  08
027B:  MOVWF  65
027C:  RLF    63,F
027D:  RLF    77,F
027E:  MOVF   64,W
027F:  SUBWF  77,W
0280:  BTFSC  03.0
0281:  MOVWF  77
0282:  RLF    78,F
0283:  DECFSZ 65,F
0284:  GOTO   27C
0285:  RETURN
0286:  MOVF   78,W
0287:  MOVF   5B,W
0288:  MOVWF  63
0289:  MOVLW  64
028A:  MOVWF  64
028B:  CALL   271
028C:  MOVF   77,W
028D:  MOVWF  5B
028E:  MOVF   78,W
028F:  MOVLW  30
0290:  BTFSS  03.2
0291:  GOTO   299
0292:  BTFSS  5C.1
0293:  GOTO   2A0
0294:  BTFSC  5C.3
0295:  GOTO   2A0
0296:  BTFSC  5C.4
0297:  MOVLW  20
0298:  GOTO   29C
0299:  BCF    5C.3
029A:  BCF    5C.4
029B:  BSF    5C.0
029C:  ADDWF  78,F
029D:  MOVF   78,W
029E:  MOVWF  5F
029F:  CALL   1EC
02A0:  MOVF   5B,W
02A1:  MOVWF  63
02A2:  MOVLW  0A
02A3:  MOVWF  64
02A4:  CALL   271
02A5:  MOVF   77,W
02A6:  MOVWF  5B
02A7:  MOVF   78,W
02A8:  MOVLW  30
02A9:  BTFSS  03.2
02AA:  GOTO   2B1
02AB:  BTFSC  5C.3
02AC:  GOTO   2B5
02AD:  BTFSS  5C.0
02AE:  GOTO   2B5
02AF:  BTFSC  5C.4
02B0:  MOVLW  20
02B1:  ADDWF  78,F
02B2:  MOVF   78,W
02B3:  MOVWF  5F
02B4:  CALL   1EC
02B5:  MOVLW  30
02B6:  ADDWF  5B,F
02B7:  MOVF   5B,W
02B8:  MOVWF  5F
02B9:  CALL   1EC
02BA:  BCF    0A.3
02BB:  BCF    0A.4
02BC:  GOTO   421 (RETURN)
02BD:  CLRF   77
02BE:  CLRF   78
02BF:  MOVF   5D,W
02C0:  BCF    03.0
02C1:  BTFSC  5E.0
02C2:  ADDWF  77,F
02C3:  RRF    77,F
02C4:  RRF    78,F
02C5:  BTFSC  5E.1
02C6:  ADDWF  77,F
02C7:  RRF    77,F
02C8:  RRF    78,F
02C9:  BTFSC  5E.2
02CA:  ADDWF  77,F
02CB:  RRF    77,F
02CC:  RRF    78,F
02CD:  BTFSC  5E.3
02CE:  ADDWF  77,F
02CF:  RRF    77,F
02D0:  RRF    78,F
02D1:  BTFSC  5E.4
02D2:  ADDWF  77,F
02D3:  RRF    77,F
02D4:  RRF    78,F
02D5:  BTFSC  5E.5
02D6:  ADDWF  77,F
02D7:  RRF    77,F
02D8:  RRF    78,F
02D9:  BTFSC  5E.6
02DA:  ADDWF  77,F
02DB:  RRF    77,F
02DC:  RRF    78,F
02DD:  BTFSC  5E.7
02DE:  ADDWF  77,F
02DF:  RRF    77,F
02E0:  RRF    78,F
02E1:  RETURN
02E2:  MOVLW  20
02E3:  BTFSS  5E.4
02E4:  MOVLW  30
02E5:  MOVWF  5F
02E6:  MOVF   5D,W
02E7:  MOVWF  77
02E8:  BTFSS  5D.7
02E9:  GOTO   2F2
02EA:  COMF   77,F
02EB:  INCF   77,F
02EC:  MOVF   77,W
02ED:  MOVWF  5D
02EE:  MOVLW  2D
02EF:  MOVWF  5F
02F0:  BSF    5E.7
02F1:  BSF    5E.0
02F2:  MOVF   5D,W
02F3:  MOVWF  63
02F4:  MOVLW  64
02F5:  MOVWF  64
02F6:  CALL   271
02F7:  MOVF   77,W
02F8:  MOVWF  5D
02F9:  MOVLW  30
02FA:  ADDWF  78,W
02FB:  MOVWF  60
02FC:  MOVF   5D,W
02FD:  MOVWF  63
02FE:  MOVLW  0A
02FF:  MOVWF  64
0300:  CALL   271
0301:  MOVLW  30
0302:  ADDWF  77,W
0303:  MOVWF  62
0304:  MOVLW  30
0305:  ADDWF  78,W
0306:  MOVWF  61
0307:  MOVF   5F,W
0308:  MOVWF  77
0309:  MOVLW  30
030A:  SUBWF  60,W
030B:  BTFSC  03.2
030C:  GOTO   311
030D:  BSF    5E.1
030E:  BTFSC  5E.7
030F:  BSF    5E.2
0310:  GOTO   325
0311:  MOVF   5F,W
0312:  MOVWF  60
0313:  MOVLW  20
0314:  MOVWF  5F
0315:  MOVLW  30
0316:  SUBWF  61,W
0317:  BTFSC  03.2
0318:  GOTO   31D
0319:  BSF    5E.0
031A:  BTFSC  5E.7
031B:  BSF    5E.1
031C:  GOTO   325
031D:  BTFSS  03.2
031E:  BSF    5E.0
031F:  BTFSS  03.2
0320:  GOTO   325
0321:  MOVF   60,W
0322:  MOVWF  61
0323:  MOVLW  20
0324:  MOVWF  60
0325:  BTFSC  5E.2
0326:  GOTO   32C
0327:  BTFSC  5E.1
0328:  GOTO   330
0329:  BTFSC  5E.0
032A:  GOTO   334
032B:  GOTO   338
032C:  MOVF   5F,W
032D:  BTFSS  0C.4
032E:  GOTO   32D
032F:  MOVWF  19
0330:  MOVF   60,W
0331:  BTFSS  0C.4
0332:  GOTO   331
0333:  MOVWF  19
0334:  MOVF   61,W
0335:  BTFSS  0C.4
0336:  GOTO   335
0337:  MOVWF  19
0338:  MOVF   62,W
0339:  BTFSS  0C.4
033A:  GOTO   339
033B:  MOVWF  19
033C:  RETURN
033D:  MOVF   0B,W
033E:  MOVWF  5E
033F:  BCF    0B.7
0340:  BSF    03.5
0341:  BSF    03.6
0342:  BSF    0C.7
0343:  BSF    0C.0
0344:  NOP
0345:  NOP
0346:  BCF    03.5
0347:  BCF    03.6
0348:  BTFSC  5E.7
0349:  BSF    0B.7
034A:  BTFSC  03.0
034B:  GOTO   375
034C:  BSF    03.6
034D:  MOVF   0C,W
034E:  ANDLW  7F
034F:  BCF    03.6
0350:  MOVWF  5E
0351:  BSF    03.6
0352:  MOVF   0D,W
0353:  BCF    03.6
0354:  MOVWF  5F
0355:  BSF    03.6
0356:  MOVF   0F,W
0357:  BCF    03.6
0358:  MOVWF  60
0359:  MOVF   5E,W
035A:  BTFSS  0C.4
035B:  GOTO   35A
035C:  MOVWF  19
035D:  MOVF   5F,W
035E:  BSF    03.6
035F:  MOVWF  0D
0360:  BCF    03.6
0361:  MOVF   60,W
0362:  BSF    03.6
0363:  MOVWF  0F
0364:  BCF    03.6
0365:  MOVF   0B,W
0366:  MOVWF  61
0367:  BCF    0B.7
0368:  BSF    03.5
0369:  BSF    03.6
036A:  BSF    0C.7
036B:  BSF    0C.0
036C:  NOP
036D:  NOP
036E:  BCF    03.5
036F:  BCF    03.6
0370:  BTFSC  61.7
0371:  BSF    0B.7
0372:  DECFSZ 5D,F
0373:  GOTO   375
0374:  GOTO   395
0375:  BSF    03.6
0376:  RLF    0C,W
0377:  RLF    0E,W
0378:  ANDLW  7F
0379:  BCF    03.6
037A:  MOVWF  5E
037B:  BSF    03.6
037C:  MOVF   0D,W
037D:  BCF    03.6
037E:  MOVWF  5F
037F:  BSF    03.6
0380:  MOVF   0F,W
0381:  BCF    03.6
0382:  MOVWF  60
0383:  MOVF   5E,W
0384:  BTFSS  0C.4
0385:  GOTO   384
0386:  MOVWF  19
0387:  MOVF   5F,W
0388:  BSF    03.6
0389:  MOVWF  0D
038A:  BCF    03.6
038B:  MOVF   60,W
038C:  BSF    03.6
038D:  MOVWF  0F
038E:  INCF   0D,F
038F:  BTFSC  03.2
0390:  INCF   0F,F
0391:  BCF    03.0
0392:  BCF    03.6
0393:  DECFSZ 5D,F
0394:  GOTO   33D
0395:  BCF    0A.3
0396:  BCF    0A.4
0397:  GOTO   5B6 (RETURN)
....................  
.................... #list 
....................  
.................... #device ADC=10 *=16   
....................  
.................... #FUSES NOWDT                    //No Watch Dog Timer 
.................... #FUSES PUT                      //Power Up Timer 
.................... #FUSES NOMCLR                   //Master Clear pin not enabled 
.................... #FUSES NOPROTECT                //Code not protected from reading 
.................... #FUSES NOCPD                    //No EE protection 
.................... #FUSES BROWNOUT                 //Brownout reset 
.................... #FUSES IESO                     //Internal External Switch Over mode enabled 
.................... #FUSES FCMEN                    //Fail-safe clock monitor enabled 
.................... #FUSES NOLVP                    //No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O 
.................... #FUSES NODEBUG                  //No Debug mode for ICD 
.................... #FUSES NOWRT                    //Program memory not write protected 
.................... #FUSES BORV40                   //Brownout reset at 4.0V 
.................... #FUSES RESERVED                 //Used to set the reserved FUSE bits 
.................... #FUSES INTRC_IO  
....................  
.................... #use delay(clock=8M) 
*
006F:  MOVLW  60
0070:  MOVWF  04
0071:  BCF    03.7
0072:  MOVF   00,W
0073:  BTFSC  03.2
0074:  GOTO   082
0075:  MOVLW  02
0076:  MOVWF  78
0077:  CLRF   77
0078:  DECFSZ 77,F
0079:  GOTO   078
007A:  DECFSZ 78,F
007B:  GOTO   077
007C:  MOVLW  97
007D:  MOVWF  77
007E:  DECFSZ 77,F
007F:  GOTO   07E
0080:  DECFSZ 00,F
0081:  GOTO   075
0082:  RETURN
....................  
.................... #use rs232(baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8) 
.................... #include <time.h> 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... ///                                                                       /// 
.................... ///                               time.h                                  /// 
.................... ///                                                                       /// 
.................... /// Time algorithms.  This follows the standard C API, with the following /// 
.................... /// exceptions:                                                           /// 
.................... ///   * ctime() and asctime() have another optional input parameter which /// 
.................... ///     is the pointer to where to save the result string.                /// 
.................... ///     Normally ctime() and asctime() write the output to a globally     /// 
.................... ///     allocated string and return a pointer to this string.  By using   /// 
.................... ///     this optional extra function parameter, you can store the         /// 
.................... ///     result string into a specified location.                          /// 
.................... ///   * The output string of ctime() and asctime() are not statically     /// 
.................... ///     allocated.  That means any other code that runs after ctime()     /// 
.................... ///     or asctime() can corrupt the result value.  Either perform        /// 
.................... ///     a string copy of the result into a new location, or use the       /// 
.................... ///     optional parameter of these functions to store the result         /// 
....................  
.................... ///   * strftime() is not supported.                                      /// 
.................... ///   * SetTime() is added that initializes/set the current time.         /// 
.................... ///   * GetTime() is added so you can read directly into a struct_tm,     /// 
.................... ///      instead of having to use localtime(time()) which is usually      /// 
.................... ///       innefecient.                                                    /// 
.................... ///   * TimeInit() added for any real time clock devices that may need    /// 
.................... ///      to be initialized first.                                         /// 
.................... ///   * Not all timebases have a tick system, so it's not recommended     /// 
.................... ///      to use clock().  If you need clock(), look at CCS's              /// 
.................... ///      #use timer() library.                                            /// 
.................... ///   * Added timeasc(), which converts a string to a time_t.  It is      /// 
.................... ///      basically the reverse of asctime().  Returns TRUE if successful  /// 
.................... ///      conversion, FALSE if not because format is wrong.                /// 
.................... ///   * Added TIME_T_USES_2010.  Normally time_t is number of seconds     /// 
.................... ///      since January 1 1970.  However, if time_t is a 32bit number this /// 
.................... ///      value will rollover sometime in 2032.  If TIME_T_USES_2010 is    /// 
.................... ///      defined then time_t is number of seconds since January 1 2010,   /// 
.................... ///      and a 32bit time_t won't rollover until 2072.   Most modern      /// 
.................... ///      operating systems (like Windows and Linux) uses a 64bit time_t   /// 
.................... ///      so they aren't effected.  If you are interfacing with another    /// 
.................... ///      system that uses a normal time_t, then that system will need to  /// 
.................... ///      add 1262304000 to the value coming from this library.            /// 
.................... ///      To enable this feature, then #define TIME_T_USES_2010            /// 
.................... ///                                                                       /// 
.................... /// This file only provides the prototypes and definitions needed to      /// 
.................... /// proved a time alogrithm that follows the C standard library.  You     /// 
.................... /// also need to include/link the actual library that performs the time   /// 
.................... /// base.  As of this writing CCS provides the following compatible       /// 
.................... /// timebase libraries:                                                   /// 
.................... ///      rtcperipheral.c - for PICs with internal real time clock.        /// 
.................... ///      ds1305.c - external DS1305 real time clock.                      /// 
.................... ///      rtcticks.c - Use a PIC's timer with CCS #use timer() library.    /// 
.................... ///                                                                       /// 
.................... /// API:                                                                  /// 
.................... ///                                                                       /// 
.................... /// Variable definitions:                                                 /// 
.................... ///   c - clock timer (clock_t), number of ticks since powerup.  See      /// 
.................... ///       CLOCKS_PER_SECOND to determine clock rate.                      /// 
.................... ///                                                                       /// 
.................... ///   t - second timer (time_t), number of seconds since Jan 1st, 1970.   /// 
.................... ///                                                                       /// 
.................... ///   ts - time struct (struct_tm), a structure that holds time in        /// 
.................... ///        descriptive format (seconds, minutes, hours, day, month, etc). /// 
.................... ///                                                                       /// 
.................... /// CLOCKS_PER_SECOND - This is a constant which needs to be defined that /// 
.................... ///   configures the timebase used by the clock timer and clock().        /// 
.................... ///   If you are not using clock() then you don't need to define this.    /// 
.................... ///   If you are using a method such a PIC's timer for the timebase then  /// 
.................... ///   you will need to set this.                                          /// 
.................... ///                                                                       /// 
.................... /// c = clock() - Return current clock timer.                             /// 
.................... ///                                                                       /// 
.................... /// t = time(*t) - Return current second timer.  Returns twice (as a      /// 
.................... ///         a return, and saves to input pointer).                        /// 
.................... ///                                                                       /// 
.................... /// SetTime(*tm) - Initializes the current time with a struct_tm          /// 
.................... ///                                                                       /// 
.................... /// SetTimeSec(t) - Initializes the current time with a seconds time      /// 
.................... ///                                                                       /// 
.................... /// t = mktime(*tm) - Converts a time struct to a second timer.           /// 
.................... ///                                                                       /// 
.................... /// t = difftime(t,t) - Returns difference between two second timers.     /// 
.................... ///                                                                       /// 
.................... /// *char = ctime(*t, *char) - Converts second timer to a readable string /// 
.................... ///                            Www Mmm dd hh:mm:ss yyyy                   /// 
.................... ///                                                                       /// 
.................... /// *char = asctime(*ts, *char) - Converts time struct to a readable      /// 
.................... ///                            string.                                    /// 
.................... ///                            Www Mmm dd hh:mm:ss yyyy                   /// 
.................... ///                                                                       /// 
.................... /// *ts = localtime(*t) - Converts second timer to a time struct.         /// 
.................... ///                  *ts points to a global time struct and will be       /// 
.................... ///                  corrupted in future calls to localtime().            /// 
.................... ///                                                                       /// 
.................... /// GetTime(*tm) - Returns the current time as a time struct              /// 
.................... ///                                                                       /// 
.................... /// TimeInit() - Initializes the timing device                            /// 
.................... ///                                                                       /// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ///                                                                     /// 
.................... /// VERSION HISTORY                                                     /// 
.................... ///                                                                     /// 
.................... /// June 9 2015:                                                        /// 
.................... ///   Fixed the struct_tm typedef so 'struct tm' would be legal         /// 
.................... ///      syntax.                                                        /// 
.................... ///   The parameters that CCS added to asctime() and ctime() are now    /// 
.................... ///      optional.                                                      /// 
.................... ///   Fixed a bug where tm_mday was sometimes off by 1 day.             /// 
.................... ///                                                                     /// 
.................... /// September 25 2014:                                                  /// 
.................... ///   Cleaned up documentation.                                         /// 
.................... ///   Added timeasc().                                                  /// 
.................... ///   Added TIME_T_USES_2010 compile time option.                       /// 
.................... ///                                                                     /// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS    //// 
.................... //// C compiler.  This source code may only be distributed to other    //// 
.................... //// licensed users of the CCS C compiler.  No other use,              //// 
.................... //// reproduction or distribution is permitted without written         //// 
.................... //// permission.  Derivative programs created using this software      //// 
.................... //// in object code form are not restricted in any way.                //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef __TIME_H__ 
.................... #define __TIME_H__ 
....................  
.................... #include <stdlibm.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... /*********************************************************************/ 
.................... #ifndef _STDLIBM 
.................... #define _STDLIBM 
....................  
.................... /* Memory Management Functions*/ 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... typedef struct nodet { 
....................    unsigned int8 size; 
....................    unsigned int8 next; }node_t; 
.................... #elif defined(__PCM__) 
.................... typedef struct nodet { 
....................    unsigned int8 size; 
....................    unsigned int16 next; }node_t; 
.................... #elif defined(__PCH__) 
.................... typedef struct nodet { 
....................    unsigned int16 size; 
....................    unsigned int16 next; }node_t; 
.................... #elif defined(__PCD__) 
.................... typedef struct nodet { 
....................    unsigned int16 size; 
....................    unsigned int16 next; }node_t; 
.................... #endif 
....................  
.................... #if !defined(STDLIBM_MANUAL_DYNAMIC_MEMORY) 
....................    #USE DYNAMIC_MEMORY 
.................... #endif 
....................  
.................... #ifndef debug_stdlibm 
....................    #define debug_stdlibm(s) 
.................... #else 
....................    #define __DO_DEBUG_STDLIBM 
....................     
....................    char g_DebugStdlibmStr[50]; 
....................     
....................    #if defined(__PCD__) 
....................       #if (defined(__PIC24E__)||defined(__dsPIC33E__)) 
....................          #define INVALID_MEMORY_LOCATION(x) ((x >= (getenv("RAM")+0x800)) || bit_test(x, 0)) 
....................       #else 
....................          #define INVALID_MEMORY_LOCATION(x) ((x >= (getenv("RAM")+0x1000)) || bit_test(x, 0)) 
....................       #endif 
....................    #else 
....................       #define INVALID_MEMORY_LOCATION(x) (x >= getenv("RAM")) 
....................    #endif 
.................... #endif 
....................  
.................... #if defined(STDLIBM_TRACK_WORST_CASE) 
....................    static size_t _g_StdlibmCurrentBytesUsed = 0; 
....................    static size_t _g_StdlibmWorstCaseBytesUsed = 0; 
....................     
....................    #define _STDLIBM_TRACK_WORST_INC(_x) \ 
....................    do {  \ 
....................       _g_StdlibmCurrentBytesUsed += _x;   \ 
....................       if (_g_StdlibmCurrentBytesUsed > _g_StdlibmWorstCaseBytesUsed) \ 
....................          _g_StdlibmWorstCaseBytesUsed = _g_StdlibmCurrentBytesUsed;  \ 
....................    } while(0) 
....................     
....................    #define _STDLIBM_TRACK_WORST_DEC(_x) _g_StdlibmCurrentBytesUsed-=_x 
.................... #else 
....................    #define _STDLIBM_TRACK_WORST_INC(_x) 
....................    #define _STDLIBM_TRACK_WORST_DEC(_x) 
.................... #endif 
....................  
.................... #include <memmgmt.c> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #if defined(__PCH__) 
....................  #define _MEMMGMT_CSIZE 32768 
....................  #define _MEMMGMT_POS 15 
.................... #elif defined(__PCD__) 
....................    #define _MEMMGMT_CSIZE 32768 
....................    #define _MEMMGMT_POS 15 
.................... #else 
....................    #define _MEMMGMT_CSIZE 127 
....................    #define _MEMMGMT_POS 7 
.................... #endif 
....................  
.................... node_t * create_node(unsigned int16 size, node_t *ptr) // create node at given location 
.................... { 
....................    node_t *result; 
....................    result =ptr; 
....................    result->size=size; 
....................    result->next = NULL; 
....................    return result; 
.................... } 
.................... void update_node(node_t *node, unsigned int16 size) // update the size of given node 
.................... { 
....................    node->size=size; 
.................... } 
....................  
.................... /* Insert node immediately after place */ //old,new 
.................... void insert_node_after(node_t *place, node_t *node)// place the node after another given node 
.................... { 
....................     if (place->next==NULL) 
....................        node->next= NULL; 
....................     else 
....................        node->next=place->next; 
....................     place->next=node; 
.................... } 
....................  
.................... ///////////////////////////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... void remove_node(node_t *node) {// remove the given node from the memlist 
....................    node_t *ptr; 
....................    for(ptr=__DYNAMIC_HEAD;ptr->next!=node;ptr=ptr->next); 
....................    ptr->next=node->next; 
....................    node=NULL; 
.................... } 
....................  
.................... ///////////////////////////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... #if defined(__DO_DEBUG_STDLIBM) 
.................... void print_list() { // print the current memlist 
....................     node_t *node; 
....................     debug_stdlibm("\r\nThe list is \n\r"); 
....................     for(node = __DYNAMIC_HEAD; node != NULL; node = node->next) 
....................     { 
....................         sprintf(g_DebugStdlibmStr, "H:0x%lx S:0x%lx N:0x%lx\n\r", node, node->size, node->next); 
....................         debug_stdlibm(g_DebugStdlibmStr); 
....................         if (INVALID_MEMORY_LOCATION(node->next)) 
....................         { 
....................            debug_stdlibm("Breaking because of invalid next node\r\n"); 
....................            break; 
....................         }    
....................     } 
....................     sprintf(g_DebugStdlibmStr, "size of node_t %u\r\n",sizeof(node_t)); 
....................     debug_stdlibm(g_DebugStdlibmStr); 
.................... } 
.................... #endif 
....................  
....................  
....................  
....................  
.................... void traverse() 
.................... { 
....................    node_t *node,*temp; 
....................    unsigned int16 nsize,nextsize; 
....................    node=__DYNAMIC_HEAD; 
....................    while(node!=NULL) 
....................    { 
....................      #if defined(__DO_DEBUG_STDLIBM) 
....................       if (INVALID_MEMORY_LOCATION(node)) 
....................       { 
....................          sprintf(g_DebugStdlibmStr, "traverse() invalid node (0x%LX)\r\n", node); 
....................          debug_stdlibm(g_DebugStdlibmStr); 
....................          break; 
....................       }    
....................      #endif 
....................      if(!bit_test(node->size,_MEMMGMT_POS))// node free 
....................       { 
....................          nsize=node->size; 
....................          temp=(unsigned int16)node->next; 
....................         #if defined(__DO_DEBUG_STDLIBM) 
....................          if (INVALID_MEMORY_LOCATION(temp)) 
....................          { 
....................             sprintf(g_DebugStdlibmStr, "traverse() invalid temp (0x%LX)\r\n", node); 
....................             debug_stdlibm(g_DebugStdlibmStr); 
....................             break; 
....................          } 
....................         #endif 
....................          if(!bit_test(temp->size,_MEMMGMT_POS)&& (temp==((unsigned int16)node+nsize+sizeof(node_t))))//next node free and consecutive, so combine 
....................          { 
....................             nextsize=temp->size; 
....................             nsize+=nextsize+sizeof(node_t); 
....................             remove_node(temp); 
....................             update_node(node,nsize); 
....................          } 
....................          else 
....................          node=node->next; 
....................       } 
....................       else 
....................       node=node->next; 
....................    } 
.................... } 
....................  
.................... char *malloc(size_t size) 
.................... { 
....................    node_t *node,*new; 
....................    unsigned int16 nsize; 
....................    #if defined(__PCD__) 
....................    if (size % 2) 
....................       size++; 
....................    #endif 
....................    node=__DYNAMIC_HEAD; 
....................     
....................   #if defined(__DO_DEBUG_STDLIBM) 
....................    sprintf(g_DebugStdlibmStr, "malloc() size=%lu ", size); 
....................    debug_stdlibm(g_DebugStdlibmStr); 
....................   #endif 
....................          
....................    while(node!=NULL) // chk until end of memlist 
....................    { 
....................      #if defined(__DO_DEBUG_STDLIBM) 
....................       if (INVALID_MEMORY_LOCATION(node)) 
....................       { 
....................          sprintf(g_DebugStdlibmStr, " invalid node (0x%LX)\r\n", node); 
....................          debug_stdlibm(g_DebugStdlibmStr); 
....................          print_list(); 
....................          return(0); 
....................       } 
....................      #endif 
....................       if(!bit_test(node->size,_MEMMGMT_POS) && node->size >=size) // node is free and > = req size 
....................       { 
....................          nsize=node->size;    //nsize = size of the node that "node" being pointed at 
....................          if(nsize>size +sizeof(node_t)) //node > req size, so split and add new node to memlist 
....................          { 
....................             new=create_node(nsize-size-sizeof(node_t),(unsigned int16)node+sizeof(node_t)+size); 
....................             insert_node_after(node,new); 
....................             update_node(node,size+_MEMMGMT_CSIZE); 
....................          } 
....................          else//not enough space for new node so use original size 
....................          update_node(node,nsize+_MEMMGMT_CSIZE); 
....................          //end if 
....................          break; 
....................       }//end if 
....................       node=node->next; 
....................    }//end while 
....................    if(node==NULL)// reached end without finding an appropriate node 
....................    { 
....................       debug_stdlibm("Not enough memory for mallocation\r\n"); 
....................       return NULL; 
....................    } 
....................    else 
....................    { 
....................      #if defined(__DO_DEBUG_STDLIBM) 
....................       sprintf(g_DebugStdlibmStr, "%LX\r\n", (char *)node+sizeof(node_t)); 
....................       debug_stdlibm(g_DebugStdlibmStr); 
....................      #endif 
....................       _STDLIBM_TRACK_WORST_INC(size); 
....................       return (char *)node+sizeof(node_t); // return pounsigned int8er to allocated space 
....................    } 
.................... } 
....................  
.................... char *calloc(size_t nmemb,size_t size) 
.................... { 
....................    node_t *node,*new; 
....................    unsigned int16 nsize,resize; 
....................    node=__DYNAMIC_HEAD; 
....................    resize=nmemb*size; 
....................    #if defined(__PCD__) 
....................    if(resize%2) 
....................       resize++; 
....................    #endif 
....................    while(node!=NULL) // chk until end of memlist 
....................    { 
....................      #if defined(__DO_DEBUG_STDLIBM) 
....................       if (INVALID_MEMORY_LOCATION(node)) 
....................       { 
....................          sprintf(g_DebugStdlibmStr, "malloc() invalid node (0x%LX)\r\n", node); 
....................          debug_stdlibm(g_DebugStdlibmStr); 
....................          print_list(); 
....................          return(0); 
....................       } 
....................      #endif 
....................       if(!bit_test(node->size,_MEMMGMT_POS) && node->size >=resize)// node is free and > = req size 
....................       { 
....................          nsize=node->size; 
....................          if(nsize>resize+sizeof(node_t))//node > req size, so split and add new node to memlist 
....................          { 
....................             new=create_node(nsize-resize-sizeof(node_t),(unsigned int16)node+sizeof(node_t)+resize); 
....................             insert_node_after(node,new); 
....................             update_node(node,resize+_MEMMGMT_CSIZE); 
....................          } 
....................          else//not enough space for new node so use original size 
....................          update_node(node,nsize+_MEMMGMT_CSIZE); 
....................          //end if 
....................          break; 
....................       }//end if 
....................       node=node->next; 
....................    }//end while 
....................    if(node==NULL)// reached end without finding an appropriate node 
....................    { 
....................       debug_stdlibm("Not enough memory for callocation\r\n"); 
....................       return NULL; 
....................    } 
....................    else 
....................    { 
....................       memset((unsigned int16)node+sizeof(node_t),0,resize);// initialize to 0 
....................       _STDLIBM_TRACK_WORST_INC(resize); 
....................       return (char *)(unsigned int16)node+sizeof(node_t);// return pounsigned int8er to allocated space 
....................    } 
.................... } 
.................... void free( void * ptr) 
.................... { 
....................    node_t *node; 
....................    unsigned int16 nsize; 
....................  
....................   #if defined(__DO_DEBUG_STDLIBM) 
....................    sprintf(g_DebugStdlibmStr, "free() 0x%LX\r\n", ptr); 
....................    debug_stdlibm(g_DebugStdlibmStr); 
....................   #endif 
....................  
....................    if(ptr==NULL) // not a valid pounsigned int8er 
....................       return; 
....................    else 
....................    { 
....................       node=ptr-sizeof(node_t); 
....................       if(bit_test(node->size,_MEMMGMT_POS))// node occupied 
....................       { 
....................          nsize=node->size-_MEMMGMT_CSIZE; 
....................          update_node(node,nsize); 
....................          ptr=NULL; 
....................          _STDLIBM_TRACK_WORST_DEC(nsize); 
....................       } 
....................       else // wrong input, return 
....................       { 
....................          ptr=NULL; 
....................          return; 
....................       } 
....................    } 
....................    traverse(); 
.................... } 
....................  
.................... char *realloc(void *ptr,size_t size) 
.................... { 
....................    node_t *node,*new,*temp; 
....................    unsigned int16 nsize,nextsize; 
....................    char *newptr; 
....................    #if defined(__PCD__) 
....................    if(size %2) 
....................       size++; 
....................    #endif 
....................    if(ptr==NULL)// null pounsigned int8er, so malloc the req memory 
....................       return(malloc(size)); 
....................    else if(size==0) 
....................    { 
....................       free(ptr); 
....................       return(NULL); 
....................    } 
....................    else 
....................    { 
....................       node=ptr-sizeof(node_t); 
....................       if(bit_test(node->size,_MEMMGMT_POS))// chk if valid pounsigned int8er 
....................       { 
....................          nsize=node->size-_MEMMGMT_CSIZE; 
....................          temp=(unsigned int16)node->next; 
....................          if(nsize>size)// block > req size 
....................          { 
....................         
....................                if(!bit_test(temp->size,_MEMMGMT_POS) && (temp==((unsigned int16)node+nsize+sizeof(node_t))))// next block free and consecutive 
....................                { 
....................                   update_node(node,size+_MEMMGMT_CSIZE); // update block 
....................                   nextsize=temp->size; 
....................                   remove_node(temp); 
....................                   new=create_node(nextsize+(nsize-size),(unsigned int16)node+size+sizeof(node_t)); 
....................                   insert_node_after(node,new); 
....................                   _STDLIBM_TRACK_WORST_DEC(nsize); 
....................                   _STDLIBM_TRACK_WORST_INC(size); 
....................                } 
....................                else if (nsize>size +sizeof(node_t))//node > req size, so split and add new node to memlist 
....................                { 
....................                   update_node(node,size+_MEMMGMT_CSIZE); // update block 
....................                   new=create_node(nsize-size-sizeof(node_t),(unsigned int16)node+sizeof(node_t)+size); 
....................                   insert_node_after(node,new); 
....................                   _STDLIBM_TRACK_WORST_DEC(nsize); 
....................                   _STDLIBM_TRACK_WORST_INC(size); 
....................                } 
....................                else//not enough space for new node so use original size 
....................                update_node(node,nsize+_MEMMGMT_CSIZE); // update block 
....................  
....................          } 
....................          else // block < req size 
....................          { 
....................             if(!bit_test(temp->size,_MEMMGMT_POS) && (temp==((unsigned int16)node+nsize+sizeof(node_t))))// next block free and consecutive 
....................             { 
....................                nextsize=temp->size; 
....................                if(nextsize>=size-nsize) // next block >=difference 
....................                { 
....................                   if(nextsize>size-nsize+sizeof(node_t))//next node > req size, so split and add new node to memlist 
....................                   { 
....................                       update_node(node,size+_MEMMGMT_CSIZE);// update block 
....................                       remove_node(temp); 
....................                       new=create_node(nextsize-(size-nsize),(unsigned int16)node+size+sizeof(node_t)); 
....................                       insert_node_after(node,new); 
....................                      _STDLIBM_TRACK_WORST_DEC(nsize); 
....................                      _STDLIBM_TRACK_WORST_INC(size); 
....................                   } 
....................                   else//not enough space for new node in next node, so use original size 
....................                   { 
....................                       update_node(node,nsize+nextsize+_MEMMGMT_CSIZE);// update block 
....................                       remove_node(temp); 
....................                   } 
....................                } 
....................                else  //next block free but too small for new size 
....................                { 
....................                   newptr = malloc(size);  //use malloc to find new block 
....................                   if(newptr == NULL) 
....................                      return(NULL);        //return NULL if malloc was unable to find new block 
....................                     
....................                   memcpy(newptr, ptr, nsize);   //copy original data to new block 
....................                   free(ptr);                    //free original block 
....................                   return(newptr);               //return new pointer 
....................                } 
....................             } 
....................             else  //next block not free 
....................             { 
....................                newptr = malloc(size);  //use malloc to find new block 
....................                if(newptr == NULL)       
....................                   return(NULL);        //return NULL if malloc was unable to find new block 
....................                 
....................                memcpy(newptr, ptr, nsize);   //copy original data to new block 
....................                free(ptr);                    //free original block 
....................                return(newptr);               //return new pointer 
....................             } 
....................          } 
....................          return (char *)node+sizeof(node_t); // return pounsigned int8er to the reallocated block 
....................       } 
....................       else // not allocated use malloc 
....................       { 
....................          return(malloc(size)); 
....................       } 
....................    } 
....................  } 
....................   
.................... typedef struct 
.................... { 
....................    size_t bytesUsed; 
....................    size_t largestUsedSeg; 
....................    int segmentsUsed; 
....................    size_t bytesFree; 
....................    size_t largestFreeSeg; 
....................    int segmentsFree; 
....................   #if defined(STDLIBM_TRACK_WORST_CASE) 
....................    size_t worstCaseBytesUsed; 
....................   #endif 
.................... } heap_status_t; 
....................  
.................... void GetHeapStatus(heap_status_t *pHeapStatus) 
.................... { 
....................    heap_status_t status; 
....................    node_t *node; 
....................    unsigned int16 nsize; 
....................     
....................    node=__DYNAMIC_HEAD; 
....................     
....................    memset(&status, 0, sizeof(status)); 
....................  
....................    while(node!=NULL) 
....................    { 
....................       nsize = node->size; 
....................       node = node->next; 
....................        
....................       if(!bit_test(nsize, _MEMMGMT_POS)) // node free 
....................       { 
....................          status.bytesFree += nsize; 
....................           
....................          status.segmentsFree++; 
....................           
....................          if (nsize > status.largestFreeSeg) 
....................          { 
....................             status.largestFreeSeg = nsize; 
....................          } 
....................       } 
....................       else 
....................       { 
....................          bit_clear(nsize, _MEMMGMT_POS); 
....................           
....................          status.bytesUsed += nsize; 
....................           
....................          status.segmentsUsed++; 
....................           
....................          if (nsize > status.largestUsedSeg) 
....................          { 
....................             status.largestUsedSeg = nsize; 
....................          } 
....................       } 
....................    } 
....................  
....................   #if defined(STDLIBM_TRACK_WORST_CASE) 
....................    status.worstCaseBytesUsed = _g_StdlibmWorstCaseBytesUsed; 
....................   #endif 
....................  
....................    memcpy(pHeapStatus, &status, sizeof(heap_status_t)); 
.................... } 
.................... #ENDIF 
....................  
....................  
.................... /* API Types*/ 
.................... typedef signed int32 time_t; 
.................... typedef unsigned int32 clock_t; 
....................  
.................... typedef enum 
.................... { 
....................    SUNDAY = 0, 
....................    MONDAY, 
....................    TUESDAY, 
....................    WEDNESDAY, 
....................    THURSDAY, 
....................    FRIDAY, 
....................    SATURDAY    
.................... }  Weekday; 
....................  
.................... typedef enum 
.................... { 
....................    JANUARY = 0, 
....................    FEBRUARY, 
....................    MARCH, 
....................    APRIL, 
....................    MAY, 
....................    JUNE, 
....................    JULY, 
....................    AUGUST, 
....................    SEPTEMBER, 
....................    OCTOBER, 
....................    NOVEMBER, 
....................    DECEMBER 
.................... }  Month; 
....................  
.................... typedef struct tm 
.................... { 
....................    unsigned int8 tm_sec;   // seconds after the minute (0-59) 
....................    unsigned int8 tm_min;   // minutes after the hour (0-59) 
....................    unsigned int8 tm_hour;  // hours since midnight (0-23) 
....................    unsigned int8 tm_mday;  // day of the month (1-31) 
....................    Month tm_mon;           // month of the year (0-11) 
....................    unsigned int16 tm_year; // years since 1900 
....................    Weekday tm_wday;        // day of the week (0-6) (Sunday=0) 
....................    unsigned int16 tm_yday; // day of the year (0-365) 
.................... } struct_tm; 
....................  
....................  
.................... /* returns number of ticks incremented at CLOCKS_PER_SECOND rate.  This 
....................    function must be provided by the library of your timebase */ 
.................... clock_t clock(void); 
....................  
.................... /* returns time in seconds since January 1 1970 (or January 1 2010 if  
....................    TIME_T_USES_2010 is being used).  This function must be provided by the 
....................    library of your timebase.  For example, see CCS's ds1305.c driver. */ 
.................... time_t time(time_t * timer); 
....................  
.................... /* Returns the difference in seconds between two times 
....................  * Times later and earlier are expressed in seconds  
....................  */ 
.................... signed int32 difftime(time_t later, time_t earlier); 
....................  
.................... /* Calculates the Unix Time from a standard time format 
....................  * Returns the Unix Time (time in seconds since Jan 1, 1970 00:00:00) 
....................  */ 
.................... time_t mktime(struct_tm * timeT); 
....................  
.................... /* Returns the given time as a string of the form:  
....................  *  Day Mon X HH:MM:SS YYYY\0  
....................  */ 
.................... char * asctime(struct_tm * timeptr, char *szTime = 0); 
....................  
.................... /* the inverse of asctime().  you can skip the wday portion of the string, and 
....................    then this function will not populate the tm_wday in pTm.  If you do skip 
....................    the wday portion of the string, then you can use localtime(mktime()) to 
....................    populate tm_wday with the correct value based on the date.  if pTm is 
....................    NULL it won't save result, but function will still return TRUE or FALSE. 
....................    Function returns TRUE if the format of the input string is valid. */ 
.................... int1 timeasc(struct_tm *pTm, char *szTime); 
....................  
.................... /* Converts the given calendar time (in seconds) to local time 
....................  * and returns the equivalent string.  
....................  */ 
.................... char * ctime(time_t * timer, char *szTime = 0); 
....................  
.................... /* Converts the given calendar time (in seconds) to local time 
....................  * and sets this time in the global g_lTime 
....................  * Returns a pointer to g_lTime 
....................  */ 
.................... struct_tm * localtime ( time_t * timer ); 
.................... #define gmtime(t) localtime(t) 
....................  
.................... /* Set the time of your system.  This function must pe provided by the library 
....................    of your timebase (see CCS's ds1305.c driver) */ 
.................... void SetTime(struct_tm * nTime); 
....................  
.................... /* Set the time of your system.  This function must pe provided by the library 
....................    of your timebase (see CCS's ds1305.c driver) */ 
.................... void SetTimeSec(time_t sTime); 
....................  
.................... /* Get the time of your system.  This is similar to the standard time() 
....................    function, but this returns directly to a struct_tm.  Since most RTC's work 
....................    with a structure similar to struct_tm, this may be more effecient to use 
....................    than time().   This function must pe provided by the library of your  
....................    timebase (see CCS's ds1305.c driver) */ 
.................... void GetTime(struct_tm *pRetTm); 
....................  
.................... /* Initialize your timebase. This function must pe provided by the library of your  
....................    timebase (see CCS's ds1305.c driver) */ 
.................... void TimeInit(void); 
....................  
.................... #endif 
....................  
.................... #include<math.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   //// 
.................... ////                 not return generic (int8 *) so type cast is done   //// 
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication //// 
.................... ////                 by its inverse to improve computation speed        //// 
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   //// 
.................... ////                 Updated routines include 64 bit versions of cos,   //// 
.................... ////                 asin,atan,exp,log and dependant functions          //// 
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    //// 
.................... ////                 and log function                                   //// 
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values //// 
.................... ////                 greater then 10000000 and less then -10000000      //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.1415926535897932 
....................  
....................  
.................... #define SQRT2  1.4142135623730950 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float32)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    {  
....................       l = (unsigned int16)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float32)l); 
....................       res = 32768.0*(float32)l; 
....................       res += (float32)(unsigned int16)y; 
....................    } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float32)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
.................... // Overloaded Functions to take care for new Data types in PCD 
.................... // Overloaded function CEIL_FLOOR() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res; 
....................    unsigned int32 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float48)(unsigned int16)y; 
....................  
....................    else if (y < 549755813888.0) 
....................    { 
....................       l = (unsigned int32)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float48)l); 
....................       res = 32768.0*(float48)l; 
....................       res += (float48)(unsigned int16)y; 
....................    } 
....................    else 
....................    {   
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float48)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
....................  
....................  
.................... // Overloaded function CEIL_FLOOR() for data type - Float64 
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res; 
....................    int64 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float64)(unsigned int16)y; 
....................    else if (y < 4503599627370496.0) 
....................    { 
....................       l = (int64)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float64)l); 
....................       res = 32768.0*(float64)l; 
....................       res += (float64)(unsigned int16)y; 
....................    } 
....................    else 
....................    { 
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float64)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................     
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 floor(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x,0); 
.................... } 
.................... // Following 2 functions are overloaded functions of floor() for PCD 
.................... // Overloaded function floor() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 floor(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... // Overloaded function floor() for data type - Float64 
.................... float64 floor(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 ceil(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... // Following 2 functions are overloaded functions of ceil() for PCD 
.................... // Overloaded function ceil() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ceil(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
.................... // Overloaded function ceil() for data type - Float64 
.................... float64 ceil(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... #endif 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //   float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float32 x,float32 y) 
.................... { 
....................    float32 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... //Overloaded function for fmod() for PCD 
.................... // Overloaded function fmod() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 fmod(float48 x,float48 y) 
.................... { 
....................    float48 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... // Overloaded function fmod() for data type - Float64 
.................... float64 fmod(float64 x,float64 y) 
.................... { 
....................    float64 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... #endif 
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... #define LN2 0.6931471805599453 
.................... #define LN2_INV 1.4426950408889634073 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
....................  
.................... float32 exp(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    #if defined(__PCD__) 
....................    int8 data1; 
....................    #endif 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
.................... #if !defined(__PCD__) 
....................    *((unsigned int8 *)(&res)) = n + 0x7F; 
.................... #endif 
....................  
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD 
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+3)) = data1; 
.................... #endif 
....................  
....................    y = y*LN2_INV - (float32)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded function for exp() for PCD 
.................... // Overloaded function exp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 exp(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int8 data1; 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+5)) = data1; 
....................  
....................    y = y*LN2_INV - (float48)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function exp() for data type - Float64 
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011, 
....................                           8.71486547014137e-009,9.84458531538385e-008, 
....................                           1.32588296983536e-006,1.52489283823016e-005, 
....................                           0.000154037598423921,0.00133335487036216, 
....................                           0.00961812936407326,0.0555041086222122, 
....................                           0.240226506962827,0.693147180559823}; 
....................  
.................... float64 exp(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    unsigned int16 data1, data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 709.7827128) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x*LN2_INV; 
....................    n = (signed int16)y; 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
.................... #if !defined(__PCD__) 
....................    *((unsigned int16 *)(&res)) = n + 0x7F; 
.................... #endif 
....................    p= (((unsigned int16 *)(&res))+3); 
....................    data1 = *p; 
....................    data2 = *p;    
....................    data1 = n + 0x3FF; 
....................    data1 = data1 <<4; 
....................    if(bit_test(data2,15)) 
....................    bit_set(data1,15); 
....................    data2 = data2 & 0x000F; 
....................    data1 ^= data2; 
....................  
....................    *(((unsigned int16 *)(&res)+3)) = data1; 
....................  
....................  
....................    y = y*LN2_INV - (float64)n; 
....................  
....................    r = pe_64[0]*y + pe_64[1]; 
....................    r = r*y + pe_64[2]; 
....................    r = r*y + pe_64[3]; 
....................    r = r*y + pe_64[4]; 
....................    r = r*y + pe_64[5]; 
....................    r = r*y + pe_64[6]; 
....................    r = r*y + pe_64[7]; 
....................    r = r*y + pe_64[8]; 
....................    r = r*y + pe_64[9]; 
....................    r = r*y + pe_64[10]; 
....................    r = r*y + pe_64[11]; 
....................     
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
.................... #ENDIF 
....................  
....................  
.................... /************************************************************/ 
....................  
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217}; 
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float32 log(float32 x) 
.................... { 
....................    float32 y, res, r, y2; 
....................    #if defined(__PCD__) 
....................    unsigned int8  data1,data2; 
....................    #endif 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
.................... #if !defined(__PCD__) 
....................     *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................  
.................... #if defined(__PCD__) // Takes care of IEEE format 
....................    data2 = *(((unsigned int8 *)(&y))+3); 
....................    *(((unsigned int8 *)(&y))+3) = 0x3F; 
....................    data1 = *(((unsigned int8 *)(&y))+2); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&y))+2) = data1; 
....................    if(bit_test(data2,7)) 
....................      bit_set(*(((unsigned int8 *)(&y))+3),7); 
.................... #endif 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
.................... #if !defined(__PCD__) 
....................       n = *((unsigned int8 *)(&x)) - 0x7E; 
.................... #endif 
.................... #if defined(__PCD__)  
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
....................     if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................     n = data1 - 0x7E; 
.................... #endif 
....................  
....................       if (n<0)  
....................          r = -(float32)-n; 
....................       else 
....................          r = (float32)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... //Overloaded function for log() for PCD 
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... // Overloaded function log() for data type - float64 
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370, 
....................                           -3.120535668274329, 2.000000000000000}; 
....................  
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234, 
....................                           1.113943039156721, -1.893601167470470}; 
....................  
.................... float48 log(float48 x) 
.................... { 
....................    float48 y, res, r, y2; 
....................    unsigned int8  data1,data2; 
....................    signed int8 n; 
.................... #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
.................... #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................  
.................... #if !defined(__PCD__) 
....................       *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................       data2 = *(((unsigned int8 *)(&y))+5); 
....................       *(((unsigned int8 *)(&y))+5) = 0x3F; 
....................       data1 = *(((unsigned int8 *)(&y))+4); 
....................       bit_clear(data1,7); 
....................       *(((unsigned int8 *)(&y))+4) = data1; 
....................  
....................       if(bit_test(data2,7)) 
....................       bit_set(*(((unsigned int8 *)(&y))+4),7); 
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0;  
....................       res = y*res/r; 
....................  
....................       data1 = *(((unsigned int8 *)(&x)+5)); 
....................       rotate_left(&data1,1); 
....................       data2 = *(((unsigned int8 *)(&x)+4)); 
....................       if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................        
....................       n = data1 - 0x7E; 
....................  
....................       if (n<0) 
....................       r = -(float48)-n; 
....................       else 
....................       r = (float48)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................    res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 log(float64 x) 
.................... { 
....................    float64 y, res, r, y2; 
....................    unsigned int16  data1,data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       p= (((unsigned int16 *)(&y))+3); 
....................       data1 = *p; 
....................       data2 = *p; 
....................       data1 = 0x3FE; 
....................       data1 = data1 <<4; 
....................       if(bit_test (data2,15)) 
....................          bit_set(data1,15); 
....................       data2 = data2 & 0x000F; 
....................       data1 ^=data2; 
....................  
....................       *p = data1; 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
....................   
....................       p= (((unsigned int16 *)(&x))+3); 
....................       data1 = *p; 
....................       bit_clear(data1,15); 
....................       data1 = data1 >>4;     
....................       n = data1 - 0x3FE; 
....................  
....................  
....................       if (n<0) 
....................          r = -(float64)-n; 
....................       else 
....................          r = (float64)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
....................  
.................... #define LN10 2.3025850929940456 
.................... #define LN10_INV 0.4342944819032518276 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float32 log10(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... //Overloaded functions for log10() for PCD 
.................... // Overloaded function log10() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log10(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function log10() for data type - Float64 
.................... float64 log10(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 modf(float32 value,float32 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... //Overloaded functions for modf() for PCD 
.................... // Overloaded function modf() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 modf(float48 value,float48 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... // Overloaded function modf() for data type - Float64 
.................... float64 modf(float64 value,float64 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pwr(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pwr() for PCD 
.................... // Overloaded function pwr() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pwr(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } else return 0; 
....................    } 
.................... } 
.................... // Overloaded function pwr() for data type - Float64 
.................... float64 pwr(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } else return 0; 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pow(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } else return 0; 
....................    } 
.................... } 
.................... //Overloaded functions for pow() for PCD 
.................... // Overloaded function for pow() data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pow(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } else return 0; 
....................    } 
.................... } 
....................  
.................... // Overloaded function pow() for data type - Float64 
.................... float64 pow(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } else return 0; 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float32 sqrt(float32 x) 
.................... { 
....................    float32 y, res; 
....................    #if defined(__PCD__) 
....................    unsigned int16 data1,data2; 
....................    #endif 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+3); 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1);     
....................     if(bit_test(data2,7))     
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for sqrt() for PCD 
.................... // Overloaded function sqrt() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sqrt(float48 x) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 data1,data2; 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+5); 
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function sqrt() for data type - Float64 
.................... float64 sqrt(float64 x) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 *p; 
....................    unsigned int16 temp1,temp2; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................    p= (((unsigned int16 *)(&y))+3); 
....................    temp1 = *p; 
....................    temp2 = *p; 
....................    bit_clear(temp1,15); 
....................    temp1 = (temp1>>4)+1023; 
....................    temp1 = temp1 >> 1; 
....................    temp1 = (temp1<<4) & 0xFFF0; 
....................    if(bit_test(temp2,15)) 
....................       bit_set(temp1,15); 
....................    temp2 = temp2 & 0x000F; 
....................    temp1 ^= temp2; 
....................     
....................    (*p) = temp1; 
....................     
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................      temp1 = *p; 
....................      temp2 = *p; 
....................      bit_clear(temp1,15); 
....................      temp1 = (temp1>>4); 
....................      temp1--; 
....................      temp1 = (temp1<<4) & 0xFFF0; 
....................      if(bit_test(temp2,15)) 
....................         bit_set(temp1,15); 
....................      temp2 = temp2 & 0x000F; 
....................      temp1 ^= temp2; 
....................      (*p) = temp1; 
....................  
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO_INV 
.................... #undef PI_DIV_BY_TWO_INV 
.................... #endif 
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO   1.5707963267948966 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #endif 
.................... #define TWOBYPI          0.6366197723675813 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 cos(float32 x) 
.................... { 
....................    float32 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float32 frac; 
....................    float32 p[5] = {                    //by the series definition for cosine 
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166663896921267, 
....................       -0.00138883894522527, 
....................        0.00002476138231734, 
....................       -0.00000026070414770 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 4; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
....................  
.................... //Overloaded functions for cos() for PCD 
.................... // Overloaded function cos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cos(float48 x) 
.................... { 
....................    float48 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float48 frac; 
....................    float48 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... // Overloaded function cos() for data type - Float64 
.................... float64 cos(float64 x) 
.................... { 
....................    float64 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float64 frac; 
....................    float64 p_64[9] = {               //by the series definition for cosine 
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )              
....................       0.04166666666656518, 
....................      -0.00138888888851691, 
....................       0.00002480158658490, 
....................      -0.00000027557239796, 
....................       0.00000000208715031, 
....................      -0.00000000001126577, 
....................       0.00000000000000427, 
....................       0.00000000000000372}; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 8; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p_64[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 sin(float32 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... //Overloaded functions for sin() for PCD 
.................... // Overloaded function sin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sin(float48 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... // Overloaded function sin() for data type - Float48 
.................... float64 sin(float64 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 tan(float32 x) 
.................... { 
....................    float32 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... //Overloaded functions for tan() for PCD 
.................... // Overloaded function tan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tan(float48 x) 
.................... { 
....................    float48 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
.................... // Overloaded function tan() for data type - Float48 
.................... float64 tan(float64 x) 
.................... { 
....................    float64 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... #endif 
....................  
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float32 ASIN_COS(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded functions for ASIN_COS() for PCD 
.................... // Overloaded function ASIN_COS() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ASIN_COS(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function ASIN_COS() for data type - Float64 
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907, 
....................                  -0.360690137621842,0.024929451660228}; 
....................  
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133, 
....................                    0.052808872045749,-0.000662536036570}; 
....................                     
.................... float64 ASIN_COS(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas_64[4]*y2 + pas_64[3]; 
....................    res = res*y2 + pas_64[2]; 
....................    res = res*y2 + pas_64[1]; 
....................    res = res*y2 + pas_64[0]; 
....................  
....................    r = qas_64[4]*y2 + qas_64[3]; 
....................    r = r*y2 + qas_64[2]; 
....................    r = r*y2 + qas_64[1]; 
....................    r = r*y2 + qas_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 asin(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for asin() for PCD 
.................... // Overloaded function asin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 asin(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function asin() for data type - Float64 
.................... float64 asin(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 acos(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for acos() for PCD 
.................... // Overloaded function acos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 acos(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function acos() for data type - Float64 
.................... float64 acos(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 atan(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for atan() for PCD 
.................... // Overloaded function atan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449, 
....................                    0.579678874003185,0.072162702162882,0.002281100141660}; 
....................  
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393, 
....................                    0.182482977188688,0.011155377971690,0.000100013019160}; 
.................... // Overloaded function atan() for data type - Float64 
.................... float64 atan(float64 x) 
.................... { 
....................    float64 y,y2, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................    y2 = y*y; 
....................    res = pat_64[5]*y2 + pat_64[4]; 
....................    res = res*y2 + pat_64[3]; 
....................    res = res*y2 + pat_64[2]; 
....................    res = res*y2 + pat_64[1]; 
....................    res = res*y2 + pat_64[0]; 
....................  
....................    r = qat_64[5]*y2 + qat_64[4]; 
....................    r = r*y2 + qat_64[3]; 
....................    r = r*y2 + qat_64[2]; 
....................    r = r*y2 + qat_64[1]; 
....................    r = r*y2 + qat_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //   float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 atan2(float32 y,float32 x) 
.................... { 
....................    float32 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //Overloaded functions for atan2() for PCD 
.................... // Overloaded function atan2() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan2(float48 y,float48 x) 
.................... { 
....................    float48 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function atan2() for data type - Float64 
.................... float64 atan2(float64 y,float64 x) 
.................... { 
....................    float64 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 cosh(float32 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for cosh() for PCD 
.................... // Overloaded function cosh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cosh(float48 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function cosh() for data type - Float64 
.................... float64 cosh(float64 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 sinh(float32 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for sinh() for PCD 
.................... // Overloaded function sinh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sinh(float48 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function sinh() for data type - Float48 
.................... float64 sinh(float64 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 tanh(float32 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... //Overloaded functions for tanh() for PCD 
.................... // Overloaded function tanh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tanh(float48 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... // Overloaded function tanh() for data type - Float64 
.................... float64 tanh(float64 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
.................... #define LOG2 .30102999566398119521 
.................... #define LOG2_INV 3.32192809488736234787 
.................... float32 frexp(float32 x, signed int8 *exp) 
.................... { 
....................    float32 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... //Overloaded functions for frexp() for PCD 
.................... // Overloaded function frexp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 frexp(float48 x, signed int8 *exp) 
.................... { 
....................    float48 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... // Overloaded function frexp() for data type - Float64 
.................... float64 frexp(float64 x, signed int8 *exp) 
.................... { 
....................    float64 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //   float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 ldexp(float32 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... //Overloaded functions for ldexp() for PCD 
.................... // Overloaded function ldexp() for data type - Float48 
....................  
.................... #if defined(__PCD__) 
.................... float48 ldexp(float48 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... // Overloaded function ldexp() for data type - Float64 
.................... float64 ldexp(float64 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #include "lcd.c" 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////                             LCD.C                                     //// 
.................... ////                 Driver for common LCD modules                         //// 
.................... ////                                                                       //// 
.................... ////  lcd_init()   Must be called before any other function.               //// 
.................... ////                                                                       //// 
.................... ////  lcd_putc(c)  Will display c on the next position of the LCD.         //// 
.................... ////                 \a  Set cursor position to upper left                 //// 
.................... ////                 \f  Clear display, set cursor to upper left           //// 
.................... ////                 \n  Go to start of second line                        //// 
.................... ////                 \b  Move back one position                            //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \n character     //// 
.................... ////              will erase all remanining characters on the current      //// 
.................... ////              line, and move the cursor to the beginning of the next   //// 
.................... ////              line.                                                    //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \r character     //// 
.................... ////              will move the cursor to the start of the current         //// 
.................... ////              line.                                                    //// 
.................... ////                                                                       //// 
.................... ////  lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1)        //// 
.................... ////                                                                       //// 
.................... ////  lcd_getc(x,y)   Returns character at position x,y on LCD             //// 
.................... ////                                                                       //// 
.................... ////  lcd_cursor_on(int1 on)   Turn the cursor on (on=TRUE) or off         //// 
.................... ////              (on=FALSE).                                              //// 
.................... ////                                                                       //// 
.................... ////  lcd_set_cgram_char(w, *p)   Write a custom character to the CGRAM.   //// 
.................... ////                                                                       //// 
.................... ////                                                                       //// 
.................... ////  CONFIGURATION                                                        //// 
.................... ////  The LCD can be configured in one of two ways: a.) port access or     //// 
.................... ////  b.) pin access.  Port access requires the entire 7 bit interface     //// 
.................... ////  connected to one GPIO port, and the data bits (D4:D7 of the LCD)     //// 
.................... ////  connected to sequential pins on the GPIO.  Pin access                //// 
.................... ////  has no requirements, all 7 bits of the control interface can         //// 
.................... ////  can be connected to any GPIO using several ports.                    //// 
.................... ////                                                                       //// 
.................... ////  To use port access, #define LCD_DATA_PORT to the SFR location of     //// 
.................... ////  of the GPIO port that holds the interface, -AND- edit LCD_PIN_MAP    //// 
.................... ////  of this file to configure the pin order.  If you are using a         //// 
.................... ////  baseline PIC (PCB), then LCD_OUTPUT_MAP and LCD_INPUT_MAP also must  //// 
.................... ////  be defined.                                                          //// 
.................... ////                                                                       //// 
.................... ////  Example of port access:                                              //// 
.................... ////     #define LCD_DATA_PORT getenv("SFR:PORTD")                         //// 
.................... ////                                                                       //// 
.................... ////  To use pin access, the following pins must be defined:               //// 
.................... ////     LCD_ENABLE_PIN                                                    //// 
.................... ////     LCD_RS_PIN                                                        //// 
.................... ////     LCD_RW_PIN                                                        //// 
.................... ////     LCD_DATA4                                                         //// 
.................... ////     LCD_DATA5                                                         //// 
.................... ////     LCD_DATA6                                                         //// 
.................... ////     LCD_DATA7                                                         //// 
.................... ////                                                                       //// 
.................... ////  Example of pin access:                                               //// 
.................... ////     #define LCD_ENABLE_PIN  PIN_E0                                    //// 
.................... ////     #define LCD_RS_PIN      PIN_E1                                    //// 
.................... ////     #define LCD_RW_PIN      PIN_E2                                    //// 
.................... ////     #define LCD_DATA4       PIN_D4                                    //// 
.................... ////     #define LCD_DATA5       PIN_D5                                    //// 
.................... ////     #define LCD_DATA6       PIN_D6                                    //// 
.................... ////     #define LCD_DATA7       PIN_D7                                    //// 
.................... ////                                                                       //// 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2010 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef __LCD_C__ 
.................... #define __LCD_C__ 
....................   
.................... #define LCD_ENABLE_PIN  PIN_B2                                    //// 
.................... #define LCD_RS_PIN      PIN_B3                                    //// 
.................... #define LCD_RW_PIN      PIN_B0                                    //// 
.................... #define LCD_DATA4       PIN_B4                                    //// 
.................... #define LCD_DATA5       PIN_B5                                    //// 
.................... #define LCD_DATA6       PIN_B6                                    //// 
.................... #define LCD_DATA7       PIN_B7   
....................   
....................   
....................   
.................... // define the pinout. 
.................... // only required if port access is being used. 
.................... typedef struct   
.................... {                            // This structure is overlayed 
....................    int1 enable;           // on to an I/O port to gain 
....................    int1 rs;               // access to the LCD pins. 
....................    int1 rw;               // The bits are allocated from 
....................    int1 unused;           // low order up.  ENABLE will 
....................    unsigned int     data : 4;         // be LSB pin of that port. 
....................   #if defined(__PCD__)       // The port used will be LCD_DATA_PORT. 
....................    unsigned int    reserved: 8; 
....................   #endif 
.................... } LCD_PIN_MAP; 
....................  
.................... // this is to improve compatability with previous LCD drivers that accepted 
.................... // a define labeled 'use_portb_lcd' that configured the LCD onto port B. 
.................... #if ((defined(use_portb_lcd)) && (use_portb_lcd==TRUE)) 
....................  #define LCD_DATA_PORT getenv("SFR:PORTB") 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    // these definitions only need to be modified for baseline PICs. 
....................    // all other PICs use LCD_PIN_MAP or individual LCD_xxx pin definitions. 
.................... /*                                    EN, RS,   RW,   UNUSED,  DATA  */ 
....................  const LCD_PIN_MAP LCD_OUTPUT_MAP =  {0,  0,    0,    0,       0}; 
....................  const LCD_PIN_MAP LCD_INPUT_MAP =   {0,  0,    0,    0,       0xF}; 
.................... #endif 
....................  
.................... ////////////////////// END CONFIGURATION /////////////////////////////////// 
....................  
.................... #ifndef LCD_ENABLE_PIN 
....................    #define lcd_output_enable(x) lcdlat.enable=x 
....................    #define lcd_enable_tris()   lcdtris.enable=0 
.................... #else 
....................    #define lcd_output_enable(x) output_bit(LCD_ENABLE_PIN, x) 
....................    #define lcd_enable_tris()  output_drive(LCD_ENABLE_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RS_PIN 
....................    #define lcd_output_rs(x) lcdlat.rs=x 
....................    #define lcd_rs_tris()   lcdtris.rs=0 
.................... #else 
....................    #define lcd_output_rs(x) output_bit(LCD_RS_PIN, x) 
....................    #define lcd_rs_tris()  output_drive(LCD_RS_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RW_PIN 
....................    #define lcd_output_rw(x) lcdlat.rw=x 
....................    #define lcd_rw_tris()   lcdtris.rw=0 
.................... #else 
....................    #define lcd_output_rw(x) output_bit(LCD_RW_PIN, x) 
....................    #define lcd_rw_tris()  output_drive(LCD_RW_PIN) 
.................... #endif 
....................  
.................... // original version of this library incorrectly labeled LCD_DATA0 as LCD_DATA4, 
.................... // LCD_DATA1 as LCD_DATA5, and so on.  this block of code makes the driver 
.................... // compatible with any code written for the original library 
.................... #if (defined(LCD_DATA0) && defined(LCD_DATA1) && defined(LCD_DATA2) && defined(LCD_DATA3) && !defined(LCD_DATA4) && !defined(LCD_DATA5) && !defined(LCD_DATA6) && !defined(LCD_DATA7)) 
....................    #define  LCD_DATA4    LCD_DATA0 
....................    #define  LCD_DATA5    LCD_DATA1 
....................    #define  LCD_DATA6    LCD_DATA2 
....................    #define  LCD_DATA7    LCD_DATA3 
.................... #endif 
....................  
.................... #ifndef LCD_DATA4 
.................... #ifndef LCD_DATA_PORT 
....................    #if defined(__PCB__) 
....................       #define LCD_DATA_PORT      0x06     //portb 
....................       #define set_tris_lcd(x)   set_tris_b(x) 
....................    #else 
....................      #if defined(PIN_D0) 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTD")     //portd 
....................      #else 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTB")     //portb 
....................      #endif 
....................    #endif    
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    LCD_PIN_MAP lcd, lcdlat; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
.................... #elif defined(__PCM__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
....................    #byte lcdtris = LCD_DATA_PORT+0x80 
.................... #elif defined(__PCH__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT+9 
....................    #byte lcdtris = LCD_DATA_PORT+0x12 
.................... #elif defined(__PCD__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #word lcd = LCD_DATA_PORT 
....................    #word lcdlat = LCD_DATA_PORT+2 
....................    #word lcdtris = LCD_DATA_PORT-0x02 
.................... #endif 
.................... #endif   //LCD_DATA4 not defined 
....................  
.................... #ifndef LCD_TYPE 
....................    #define LCD_TYPE 2           // 0=5x7, 1=5x10, 2=2 lines 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_TWO 
....................    #define LCD_LINE_TWO 0x40    // LCD RAM address for the second line 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_LENGTH 
....................    #define LCD_LINE_LENGTH 20 
.................... #endif 
....................  
.................... unsigned int8 lcd_read_nibble(void); 
....................  
.................... unsigned int8 lcd_read_byte(void) 
.................... { 
....................    unsigned int8 low,high; 
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_INPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_float(LCD_DATA4); 
*
00E8:  BSF    06.4
....................    output_float(LCD_DATA5); 
00E9:  BSF    06.5
....................    output_float(LCD_DATA6); 
00EA:  BSF    06.6
....................    output_float(LCD_DATA7); 
00EB:  BSF    06.7
....................   #else 
....................    lcdtris.data = 0xF; 
....................   #endif 
....................  #endif 
....................          
....................    lcd_output_rw(1); 
00EC:  BCF    03.5
00ED:  BSF    06.0
00EE:  BSF    03.5
00EF:  BCF    06.0
....................    delay_cycles(1); 
00F0:  NOP
....................    lcd_output_enable(1); 
00F1:  BCF    03.5
00F2:  BSF    06.2
00F3:  BSF    03.5
00F4:  BCF    06.2
....................    delay_cycles(1); 
00F5:  NOP
....................    high = lcd_read_nibble(); 
00F6:  BCF    03.5
00F7:  CALL   0AF
00F8:  MOVF   78,W
00F9:  MOVWF  67
....................        
....................    lcd_output_enable(0); 
00FA:  BCF    06.2
00FB:  BSF    03.5
00FC:  BCF    06.2
....................    delay_cycles(1); 
00FD:  NOP
....................    lcd_output_enable(1); 
00FE:  BCF    03.5
00FF:  BSF    06.2
0100:  BSF    03.5
0101:  BCF    06.2
....................    delay_us(1); 
0102:  GOTO   103
....................    low = lcd_read_nibble(); 
0103:  BCF    03.5
0104:  CALL   0AF
0105:  MOVF   78,W
0106:  MOVWF  66
....................        
....................    lcd_output_enable(0); 
0107:  BCF    06.2
0108:  BSF    03.5
0109:  BCF    06.2
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
010A:  BCF    06.4
....................    output_drive(LCD_DATA5); 
010B:  BCF    06.5
....................    output_drive(LCD_DATA6); 
010C:  BCF    06.6
....................    output_drive(LCD_DATA7); 
010D:  BCF    06.7
....................   #else 
....................    lcdtris.data = 0x0; 
....................   #endif 
....................  #endif 
....................  
....................    return( (high<<4) | low); 
010E:  BCF    03.5
010F:  SWAPF  67,W
0110:  MOVWF  77
0111:  MOVLW  F0
0112:  ANDWF  77,F
0113:  MOVF   77,W
0114:  IORWF  66,W
0115:  MOVWF  78
.................... } 
....................  
.................... unsigned int8 lcd_read_nibble(void) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
*
00AF:  CLRF   68
....................    unsigned int8 n = 0x00; 
....................  
....................    /* Read the data port */ 
....................    n |= input(LCD_DATA4); 
00B0:  BSF    03.5
00B1:  BSF    06.4
00B2:  MOVLW  00
00B3:  BCF    03.5
00B4:  BTFSC  06.4
00B5:  MOVLW  01
00B6:  IORWF  68,F
....................    n |= input(LCD_DATA5) << 1; 
00B7:  BSF    03.5
00B8:  BSF    06.5
00B9:  MOVLW  00
00BA:  BCF    03.5
00BB:  BTFSC  06.5
00BC:  MOVLW  01
00BD:  MOVWF  77
00BE:  BCF    03.0
00BF:  RLF    77,F
00C0:  MOVF   77,W
00C1:  IORWF  68,F
....................    n |= input(LCD_DATA6) << 2; 
00C2:  BSF    03.5
00C3:  BSF    06.6
00C4:  MOVLW  00
00C5:  BCF    03.5
00C6:  BTFSC  06.6
00C7:  MOVLW  01
00C8:  MOVWF  77
00C9:  RLF    77,F
00CA:  RLF    77,F
00CB:  MOVLW  FC
00CC:  ANDWF  77,F
00CD:  MOVF   77,W
00CE:  IORWF  68,F
....................    n |= input(LCD_DATA7) << 3; 
00CF:  BSF    03.5
00D0:  BSF    06.7
00D1:  MOVLW  00
00D2:  BCF    03.5
00D3:  BTFSC  06.7
00D4:  MOVLW  01
00D5:  MOVWF  77
00D6:  RLF    77,F
00D7:  RLF    77,F
00D8:  RLF    77,F
00D9:  MOVLW  F8
00DA:  ANDWF  77,F
00DB:  MOVF   77,W
00DC:  IORWF  68,F
....................     
....................    return(n); 
00DD:  MOVF   68,W
00DE:  MOVWF  78
....................   #else 
00DF:  RETURN
....................    return(lcd.data); 
....................   #endif 
.................... } 
....................  
.................... void lcd_send_nibble(unsigned int8 n) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    /* Write to the data port */ 
....................    output_bit(LCD_DATA4, bit_test(n, 0)); 
*
0083:  BTFSC  67.0
0084:  GOTO   087
0085:  BCF    06.4
0086:  GOTO   088
0087:  BSF    06.4
0088:  BSF    03.5
0089:  BCF    06.4
....................    output_bit(LCD_DATA5, bit_test(n, 1)); 
008A:  BCF    03.5
008B:  BTFSC  67.1
008C:  GOTO   08F
008D:  BCF    06.5
008E:  GOTO   090
008F:  BSF    06.5
0090:  BSF    03.5
0091:  BCF    06.5
....................    output_bit(LCD_DATA6, bit_test(n, 2)); 
0092:  BCF    03.5
0093:  BTFSC  67.2
0094:  GOTO   097
0095:  BCF    06.6
0096:  GOTO   098
0097:  BSF    06.6
0098:  BSF    03.5
0099:  BCF    06.6
....................    output_bit(LCD_DATA7, bit_test(n, 3)); 
009A:  BCF    03.5
009B:  BTFSC  67.3
009C:  GOTO   09F
009D:  BCF    06.7
009E:  GOTO   0A0
009F:  BSF    06.7
00A0:  BSF    03.5
00A1:  BCF    06.7
....................   #else       
....................    lcdlat.data = n; 
....................   #endif 
....................        
....................    delay_cycles(1); 
00A2:  NOP
....................    lcd_output_enable(1); 
00A3:  BCF    03.5
00A4:  BSF    06.2
00A5:  BSF    03.5
00A6:  BCF    06.2
....................    delay_us(2); 
00A7:  GOTO   0A8
00A8:  GOTO   0A9
....................    lcd_output_enable(0); 
00A9:  BCF    03.5
00AA:  BCF    06.2
00AB:  BSF    03.5
00AC:  BCF    06.2
00AD:  BCF    03.5
00AE:  RETURN
.................... } 
....................  
.................... void lcd_send_byte(unsigned int8 address, unsigned int8 n) 
.................... { 
....................   #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................   #else 
....................    lcd_enable_tris(); 
*
00E0:  BSF    03.5
00E1:  BCF    06.2
....................    lcd_rs_tris(); 
00E2:  BCF    06.3
....................    lcd_rw_tris(); 
00E3:  BCF    06.0
....................   #endif 
....................  
....................    lcd_output_rs(0); 
00E4:  BCF    03.5
00E5:  BCF    06.3
00E6:  BSF    03.5
00E7:  BCF    06.3
....................    while ( bit_test(lcd_read_byte(),7) ) ; 
*
0116:  MOVF   78,W
0117:  MOVWF  66
0118:  BTFSS  66.7
0119:  GOTO   11C
011A:  BSF    03.5
011B:  GOTO   0E8
....................    lcd_output_rs(address); 
011C:  MOVF   64,F
011D:  BTFSS  03.2
011E:  GOTO   121
011F:  BCF    06.3
0120:  GOTO   122
0121:  BSF    06.3
0122:  BSF    03.5
0123:  BCF    06.3
....................    delay_cycles(1); 
0124:  NOP
....................    lcd_output_rw(0); 
0125:  BCF    03.5
0126:  BCF    06.0
0127:  BSF    03.5
0128:  BCF    06.0
....................    delay_cycles(1); 
0129:  NOP
....................    lcd_output_enable(0); 
012A:  BCF    03.5
012B:  BCF    06.2
012C:  BSF    03.5
012D:  BCF    06.2
....................    lcd_send_nibble(n >> 4); 
012E:  BCF    03.5
012F:  SWAPF  65,W
0130:  MOVWF  66
0131:  MOVLW  0F
0132:  ANDWF  66,F
0133:  MOVF   66,W
0134:  MOVWF  67
0135:  CALL   083
....................    lcd_send_nibble(n & 0xf); 
0136:  MOVF   65,W
0137:  ANDLW  0F
0138:  MOVWF  66
0139:  MOVWF  67
013A:  CALL   083
013B:  RETURN
.................... } 
....................  
.................... #if defined(LCD_EXTENDED_NEWLINE) 
.................... unsigned int8 g_LcdX, g_LcdY; 
.................... #endif 
....................  
.................... void lcd_init(void)  
.................... { 
....................    unsigned int8 i; 
....................    unsigned int8 LCD_INIT_STRING[4] = {0x20 | (LCD_TYPE << 2), 0xc, 1, 6}; 
013C:  MOVLW  28
013D:  MOVWF  5C
013E:  MOVLW  0C
013F:  MOVWF  5D
0140:  MOVLW  01
0141:  MOVWF  5E
0142:  MOVLW  06
0143:  MOVWF  5F
....................                              // These bytes need to be sent to the LCD 
....................                              // to start it up. 
....................     
....................  
....................    lcd_output_enable(0); 
0144:  BCF    06.2
0145:  BSF    03.5
0146:  BCF    06.2
....................    lcd_output_rs(0); 
0147:  BCF    03.5
0148:  BCF    06.3
0149:  BSF    03.5
014A:  BCF    06.3
....................    lcd_output_rw(0); 
014B:  BCF    03.5
014C:  BCF    06.0
014D:  BSF    03.5
014E:  BCF    06.0
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
014F:  BCF    06.4
....................    output_drive(LCD_DATA5); 
0150:  BCF    06.5
....................    output_drive(LCD_DATA6); 
0151:  BCF    06.6
....................    output_drive(LCD_DATA7); 
0152:  BCF    06.7
....................   #else 
....................    lcdtris.data = 0x0; 
....................   #endif 
....................    lcd_enable_tris(); 
0153:  BCF    06.2
....................    lcd_rs_tris(); 
0154:  BCF    06.3
....................    lcd_rw_tris(); 
0155:  BCF    06.0
....................  #endif 
....................      
....................    delay_ms(15); 
0156:  MOVLW  0F
0157:  BCF    03.5
0158:  MOVWF  60
0159:  CALL   06F
....................    for(i=1;i<=3;++i) 
015A:  MOVLW  01
015B:  MOVWF  5B
015C:  MOVF   5B,W
015D:  SUBLW  03
015E:  BTFSS  03.0
015F:  GOTO   168
....................    { 
....................        lcd_send_nibble(3); 
0160:  MOVLW  03
0161:  MOVWF  67
0162:  CALL   083
....................        delay_ms(5); 
0163:  MOVLW  05
0164:  MOVWF  60
0165:  CALL   06F
0166:  INCF   5B,F
0167:  GOTO   15C
....................    } 
....................     
....................    lcd_send_nibble(2); 
0168:  MOVLW  02
0169:  MOVWF  67
016A:  CALL   083
....................    delay_ms(5); 
016B:  MOVLW  05
016C:  MOVWF  60
016D:  CALL   06F
....................    for(i=0;i<=3;++i) 
016E:  CLRF   5B
016F:  MOVF   5B,W
0170:  SUBLW  03
0171:  BTFSS  03.0
0172:  GOTO   17F
....................       lcd_send_byte(0,LCD_INIT_STRING[i]); 
0173:  MOVLW  5C
0174:  ADDWF  5B,W
0175:  MOVWF  04
0176:  BCF    03.7
0177:  MOVF   00,W
0178:  MOVWF  60
0179:  CLRF   64
017A:  MOVF   60,W
017B:  MOVWF  65
017C:  CALL   0E0
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
017D:  INCF   5B,F
017E:  GOTO   16F
017F:  BCF    0A.3
0180:  BCF    0A.4
0181:  GOTO   401 (RETURN)
....................    g_LcdX = 0; 
....................    g_LcdY = 0; 
....................   #endif 
.................... } 
....................  
.................... void lcd_gotoxy(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    unsigned int8 address; 
....................     
....................    if(y!=1) 
*
01DA:  DECFSZ 61,W
01DB:  GOTO   1DD
01DC:  GOTO   1E0
....................       address=LCD_LINE_TWO; 
01DD:  MOVLW  40
01DE:  MOVWF  62
01DF:  GOTO   1E1
....................    else 
....................       address=0; 
01E0:  CLRF   62
....................       
....................    address+=x-1; 
01E1:  MOVLW  01
01E2:  SUBWF  60,W
01E3:  ADDWF  62,F
....................    lcd_send_byte(0,0x80|address); 
01E4:  MOVF   62,W
01E5:  IORLW  80
01E6:  MOVWF  63
01E7:  CLRF   64
01E8:  MOVF   63,W
01E9:  MOVWF  65
01EA:  CALL   0E0
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
01EB:  RETURN
....................    g_LcdX = x - 1; 
....................    g_LcdY = y - 1; 
....................   #endif 
.................... } 
....................  
.................... void lcd_putc(char c) 
.................... { 
....................    switch (c) 
01EC:  MOVF   5F,W
01ED:  XORLW  07
01EE:  BTFSC  03.2
01EF:  GOTO   1FA
01F0:  XORLW  0B
01F1:  BTFSC  03.2
01F2:  GOTO   1FF
01F3:  XORLW  06
01F4:  BTFSC  03.2
01F5:  GOTO   207
01F6:  XORLW  02
01F7:  BTFSC  03.2
01F8:  GOTO   20D
01F9:  GOTO   212
....................    { 
....................       case '\a'   :  lcd_gotoxy(1,1);     break; 
01FA:  MOVLW  01
01FB:  MOVWF  60
01FC:  MOVWF  61
01FD:  CALL   1DA
01FE:  GOTO   217
....................  
....................       case '\f'   :  lcd_send_byte(0,1); 
01FF:  CLRF   64
0200:  MOVLW  01
0201:  MOVWF  65
0202:  CALL   0E0
....................                      delay_ms(2); 
0203:  MOVLW  02
0204:  MOVWF  60
0205:  CALL   06F
....................                     #if defined(LCD_EXTENDED_NEWLINE) 
....................                      g_LcdX = 0; 
....................                      g_LcdY = 0; 
....................                     #endif 
....................                      break; 
0206:  GOTO   217
....................  
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       case '\r'   :  lcd_gotoxy(1, g_LcdY+1);   break; 
....................       case '\n'   : 
....................          while (g_LcdX++ < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, ' '); 
....................          } 
....................          lcd_gotoxy(1, g_LcdY+2); 
....................          break; 
....................      #else 
....................       case '\n'   : lcd_gotoxy(1,2);        break; 
0207:  MOVLW  01
0208:  MOVWF  60
0209:  MOVLW  02
020A:  MOVWF  61
020B:  CALL   1DA
020C:  GOTO   217
....................      #endif 
....................       
....................       case '\b'   : lcd_send_byte(0,0x10);  break; 
020D:  CLRF   64
020E:  MOVLW  10
020F:  MOVWF  65
0210:  CALL   0E0
0211:  GOTO   217
....................       
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       default     :  
....................          if (g_LcdX < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, c); 
....................             g_LcdX++; 
....................          } 
....................          break; 
....................      #else 
....................       default     : lcd_send_byte(1,c);     break; 
0212:  MOVLW  01
0213:  MOVWF  64
0214:  MOVF   5F,W
0215:  MOVWF  65
0216:  CALL   0E0
....................      #endif 
....................    } 
0217:  RETURN
.................... } 
....................   
.................... char lcd_getc(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    char value; 
....................  
....................    lcd_gotoxy(x,y); 
....................    while ( bit_test(lcd_read_byte(),7) ); // wait until busy flag is low 
....................    lcd_output_rs(1); 
....................    value = lcd_read_byte(); 
....................    lcd_output_rs(0); 
....................     
....................    return(value); 
.................... } 
....................  
.................... // write a custom character to the ram 
.................... // which is 0-7 and specifies which character array we are modifying. 
.................... // ptr points to an array of 8 bytes, where each byte is the next row of 
.................... //    pixels.  only bits 0-4 are used.  the last row is the cursor row, and 
.................... //    usually you will want to leave this byte 0x00. 
.................... void lcd_set_cgram_char(unsigned int8 which, unsigned int8 *ptr) 
.................... { 
....................    unsigned int i; 
....................  
....................    which <<= 3; 
....................    which &= 0x38; 
....................  
....................    lcd_send_byte(0, 0x40 | which);  //set cgram address 
....................  
....................    for(i=0; i<8; i++) 
....................    { 
....................       lcd_send_byte(1, *ptr++); 
....................    } 
....................    
....................    #if defined(LCD_EXTENDED_NEWLINE) 
....................     lcd_gotoxy(g_LcdX+1, g_LcdY+1);  //set ddram address 
....................    #endif 
.................... } 
....................  
.................... void lcd_cursor_on(int1 on) 
.................... { 
....................    if (on) 
....................    { 
....................       lcd_send_byte(0,0x0F);           //turn LCD cursor ON 
....................    } 
....................    else 
....................    { 
....................       lcd_send_byte(0,0x0C);           //turn LCD cursor OFF 
....................    } 
.................... } 
....................  
.................... #endif 
....................  
.................... #define RESET_BUTTON    PIN_d0 
.................... #DEFINE n 4 
....................  
....................  
.................... void main() 
*
0398:  MOVF   03,W
0399:  ANDLW  1F
039A:  MOVWF  03
039B:  MOVLW  71
039C:  BSF    03.5
039D:  MOVWF  0F
039E:  CLRF   10
039F:  MOVF   0F,W
03A0:  BSF    03.6
03A1:  BCF    07.3
03A2:  MOVLW  0C
03A3:  BCF    03.6
03A4:  MOVWF  19
03A5:  MOVLW  A2
03A6:  MOVWF  18
03A7:  MOVLW  90
03A8:  BCF    03.5
03A9:  MOVWF  18
03AA:  CLRF   23
03AB:  CLRF   22
03AC:  BSF    03.5
03AD:  BSF    03.6
03AE:  MOVF   09,W
03AF:  ANDLW  C0
03B0:  MOVWF  09
03B1:  BCF    03.6
03B2:  BCF    1F.4
03B3:  BCF    1F.5
03B4:  MOVLW  00
03B5:  BSF    03.6
03B6:  MOVWF  08
03B7:  BCF    03.5
03B8:  CLRF   07
03B9:  CLRF   08
03BA:  CLRF   09
03BB:  BCF    03.6
03BC:  CLRF   21
03BD:  MOVLW  6A
03BE:  MOVWF  20
03BF:  MOVLW  0A
03C0:  MOVWF  6A
03C1:  CLRF   6C
03C2:  MOVLW  A0
03C3:  MOVWF  6B
03C4:  MOVLW  4D
03C5:  BSF    03.5
03C6:  MOVWF  20
03C7:  MOVLW  01
03C8:  MOVWF  22
03C9:  MOVLW  10
03CA:  MOVWF  21
03CB:  MOVLW  5D
03CC:  BCF    03.5
03CD:  BSF    03.6
03CE:  MOVWF  10
03CF:  MOVLW  01
03D0:  MOVWF  12
03D1:  MOVLW  90
03D2:  MOVWF  11
03D3:  MOVLW  5D
03D4:  BSF    03.5
03D5:  MOVWF  10
03D6:  CLRF   12
03D7:  CLRF   11
03D8:  BCF    03.5
03D9:  BCF    03.6
03DA:  BCF    03.7
*
03FB:  MOVLW  D3
03FC:  MOVWF  44
03FD:  MOVLW  01
03FE:  MOVWF  45
03FF:  CLRF   46
.................... {   
....................     
....................    int board[n][n] = {0}; 
*
03DB:  CLRF   24
03DC:  CLRF   25
03DD:  CLRF   26
03DE:  CLRF   27
03DF:  CLRF   28
03E0:  CLRF   29
03E1:  CLRF   2A
03E2:  CLRF   2B
03E3:  CLRF   2C
03E4:  CLRF   2D
03E5:  CLRF   2E
03E6:  CLRF   2F
03E7:  CLRF   30
03E8:  CLRF   31
03E9:  CLRF   32
03EA:  CLRF   33
....................    int freePos[n*n]={0}; 
03EB:  CLRF   34
03EC:  CLRF   35
03ED:  CLRF   36
03EE:  CLRF   37
03EF:  CLRF   38
03F0:  CLRF   39
03F1:  CLRF   3A
03F2:  CLRF   3B
03F3:  CLRF   3C
03F4:  CLRF   3D
03F5:  CLRF   3E
03F6:  CLRF   3F
03F7:  CLRF   40
03F8:  CLRF   41
03F9:  CLRF   42
03FA:  CLRF   43
....................    int gen1 = 211, gen2 = 257; 
....................    int score = 0; 
....................    char keyInput;//get input. 
....................    int randPos;//random number position to fill a new item(number 2) in board. 
....................    int newPos; 
....................    int value; 
....................    boolean canMove; 
....................     
....................    lcd_init(); 
*
0400:  GOTO   13C
....................    delay_ms(6); 
0401:  MOVLW  06
0402:  MOVWF  60
0403:  CALL   06F
....................     
....................    printf ("\t\t< Welcome to 2048 game >\r\n"); 
0404:  MOVLW  04
0405:  BSF    03.6
0406:  MOVWF  0D
0407:  MOVLW  00
0408:  MOVWF  0F
0409:  BCF    03.6
040A:  CALL   182
....................    printf ("'a' = Left  'd' = Right  'w' = Up  's' = Down\r\n\n"); 
040B:  MOVLW  13
040C:  BSF    03.6
040D:  MOVWF  0D
040E:  MOVLW  00
040F:  MOVWF  0F
0410:  BCF    03.6
0411:  CALL   182
....................     
....................    while(TRUE) { 
....................       printf(lcd_putc,"\fYour score\n%u", score); 
0412:  MOVLW  2C
0413:  BSF    03.6
0414:  MOVWF  0D
0415:  MOVLW  00
0416:  MOVWF  0F
0417:  BCF    03.0
0418:  MOVLW  0C
0419:  BCF    03.6
041A:  MOVWF  5B
041B:  GOTO   218
041C:  MOVF   46,W
041D:  MOVWF  5B
041E:  MOVLW  1B
041F:  MOVWF  5C
0420:  GOTO   286
....................       delay_ms(1); 
0421:  MOVLW  01
0422:  MOVWF  60
0423:  CALL   06F
....................        
....................       //---------------------------game over check-----------------------------------------// 
....................       boolean canMove = false; 
....................       int count = 0; 
0424:  BCF    4B.1
0425:  CLRF   4C
....................       for(int i=0;i<n;i++){ 
0426:  CLRF   4D
0427:  MOVF   4D,W
0428:  SUBLW  03
0429:  BTFSS  03.0
042A:  GOTO   505
....................          for(int j=0;j<n;j++){ 
042B:  CLRF   4E
042C:  MOVF   4E,W
042D:  SUBLW  03
042E:  BTFSS  03.0
042F:  GOTO   503
....................             if(board[i][j] == 0){ 
0430:  RLF    4D,W
0431:  MOVWF  77
0432:  RLF    77,F
0433:  MOVLW  FC
0434:  ANDWF  77,F
0435:  MOVF   77,W
0436:  ADDWF  4E,W
0437:  ADDLW  24
0438:  MOVWF  04
0439:  BCF    03.7
043A:  MOVF   00,F
043B:  BTFSS  03.2
043C:  GOTO   44B
....................                freePos[count++] = (i * n) + j; 
043D:  MOVF   4C,W
043E:  INCF   4C,F
043F:  ADDLW  34
0440:  MOVWF  04
0441:  BCF    03.7
0442:  RLF    4D,W
0443:  MOVWF  77
0444:  RLF    77,F
0445:  MOVLW  FC
0446:  ANDWF  77,F
0447:  MOVF   77,W
0448:  ADDWF  4E,W
0449:  MOVWF  00
....................                canMove = true; 
044A:  BSF    4B.1
....................             } 
....................             if((i != 0 && (board[i-1][j] == 0 || board[i-1][j] == board[i][j])) || 
....................                (i != n-1 && (board[i+1][j] == 0 || board[i+1][j] == board[i][j])) || 
....................                (j != 0 && (board[i][j-1] == 0 || board[i][j-1] == board[i][j])) || 
....................                (j != n-1 && (board[i][j+1] == 0 || board[i][j+1] == board[i][j]))) canMove = true; 
044B:  MOVF   4D,F
044C:  BTFSC  03.2
044D:  GOTO   479
044E:  MOVLW  01
044F:  SUBWF  4D,W
0450:  MOVWF  77
0451:  RLF    77,F
0452:  RLF    77,F
0453:  MOVLW  FC
0454:  ANDWF  77,F
0455:  MOVF   77,W
0456:  ADDWF  4E,W
0457:  ADDLW  24
0458:  MOVWF  04
0459:  BCF    03.7
045A:  MOVF   00,F
045B:  BTFSC  03.2
045C:  GOTO   500
045D:  MOVLW  01
045E:  SUBWF  4D,W
045F:  MOVWF  77
0460:  RLF    77,F
0461:  RLF    77,F
0462:  MOVLW  FC
0463:  ANDWF  77,F
0464:  MOVF   77,W
0465:  ADDWF  4E,W
0466:  ADDLW  24
0467:  MOVWF  04
0468:  BCF    03.7
0469:  MOVF   00,W
046A:  MOVWF  5B
046B:  RLF    4D,W
046C:  MOVWF  77
046D:  RLF    77,F
046E:  MOVLW  FC
046F:  ANDWF  77,F
0470:  MOVF   77,W
0471:  ADDWF  4E,W
0472:  ADDLW  24
0473:  MOVWF  04
0474:  BCF    03.7
0475:  MOVF   00,W
0476:  SUBWF  5B,W
0477:  BTFSC  03.2
0478:  GOTO   500
0479:  MOVF   4D,W
047A:  SUBLW  03
047B:  BTFSC  03.2
047C:  GOTO   4A8
047D:  MOVLW  01
047E:  ADDWF  4D,W
047F:  MOVWF  77
0480:  RLF    77,F
0481:  RLF    77,F
0482:  MOVLW  FC
0483:  ANDWF  77,F
0484:  MOVF   77,W
0485:  ADDWF  4E,W
0486:  ADDLW  24
0487:  MOVWF  04
0488:  BCF    03.7
0489:  MOVF   00,F
048A:  BTFSC  03.2
048B:  GOTO   500
048C:  MOVLW  01
048D:  ADDWF  4D,W
048E:  MOVWF  77
048F:  RLF    77,F
0490:  RLF    77,F
0491:  MOVLW  FC
0492:  ANDWF  77,F
0493:  MOVF   77,W
0494:  ADDWF  4E,W
0495:  ADDLW  24
0496:  MOVWF  04
0497:  BCF    03.7
0498:  MOVF   00,W
0499:  MOVWF  5B
049A:  RLF    4D,W
049B:  MOVWF  77
049C:  RLF    77,F
049D:  MOVLW  FC
049E:  ANDWF  77,F
049F:  MOVF   77,W
04A0:  ADDWF  4E,W
04A1:  ADDLW  24
04A2:  MOVWF  04
04A3:  BCF    03.7
04A4:  MOVF   00,W
04A5:  SUBWF  5B,W
04A6:  BTFSC  03.2
04A7:  GOTO   500
04A8:  MOVF   4E,F
04A9:  BTFSC  03.2
04AA:  GOTO   4D4
04AB:  RLF    4D,W
04AC:  MOVWF  5B
04AD:  RLF    5B,F
04AE:  MOVLW  FC
04AF:  ANDWF  5B,F
04B0:  MOVLW  01
04B1:  SUBWF  4E,W
04B2:  ADDWF  5B,W
04B3:  ADDLW  24
04B4:  MOVWF  04
04B5:  BCF    03.7
04B6:  MOVF   00,F
04B7:  BTFSC  03.2
04B8:  GOTO   500
04B9:  RLF    4D,W
04BA:  MOVWF  5B
04BB:  RLF    5B,F
04BC:  MOVLW  FC
04BD:  ANDWF  5B,F
04BE:  MOVLW  01
04BF:  SUBWF  4E,W
04C0:  ADDWF  5B,W
04C1:  ADDLW  24
04C2:  MOVWF  04
04C3:  BCF    03.7
04C4:  MOVF   00,W
04C5:  MOVWF  5B
04C6:  RLF    4D,W
04C7:  MOVWF  77
04C8:  RLF    77,F
04C9:  MOVLW  FC
04CA:  ANDWF  77,F
04CB:  MOVF   77,W
04CC:  ADDWF  4E,W
04CD:  ADDLW  24
04CE:  MOVWF  04
04CF:  BCF    03.7
04D0:  MOVF   00,W
04D1:  SUBWF  5B,W
04D2:  BTFSC  03.2
04D3:  GOTO   500
04D4:  MOVF   4E,W
04D5:  SUBLW  03
04D6:  BTFSC  03.2
04D7:  GOTO   501
04D8:  RLF    4D,W
04D9:  MOVWF  5B
04DA:  RLF    5B,F
04DB:  MOVLW  FC
04DC:  ANDWF  5B,F
04DD:  MOVLW  01
04DE:  ADDWF  4E,W
04DF:  ADDWF  5B,W
04E0:  ADDLW  24
04E1:  MOVWF  04
04E2:  BCF    03.7
04E3:  MOVF   00,F
04E4:  BTFSC  03.2
04E5:  GOTO   500
04E6:  RLF    4D,W
04E7:  MOVWF  5B
04E8:  RLF    5B,F
04E9:  MOVLW  FC
04EA:  ANDWF  5B,F
04EB:  MOVLW  01
04EC:  ADDWF  4E,W
04ED:  ADDWF  5B,W
04EE:  ADDLW  24
04EF:  MOVWF  04
04F0:  BCF    03.7
04F1:  MOVF   00,W
04F2:  MOVWF  5B
04F3:  RLF    4D,W
04F4:  MOVWF  77
04F5:  RLF    77,F
04F6:  MOVLW  FC
04F7:  ANDWF  77,F
04F8:  MOVF   77,W
04F9:  ADDWF  4E,W
04FA:  ADDLW  24
04FB:  MOVWF  04
04FC:  BCF    03.7
04FD:  MOVF   00,W
04FE:  SUBWF  5B,W
04FF:  BTFSC  03.2
0500:  BSF    4B.1
0501:  INCF   4E,F
0502:  GOTO   42C
....................          } 
0503:  INCF   4D,F
0504:  GOTO   427
....................       } 
....................       if(!canMove) { 
0505:  BTFSC  4B.1
0506:  GOTO   50F
....................          printf("\t\t\t!Game Over!\r\n"); 
0507:  MOVLW  34
0508:  BSF    03.6
0509:  MOVWF  0D
050A:  MOVLW  00
050B:  MOVWF  0F
050C:  BCF    03.6
050D:  CALL   182
....................          break; 
050E:  GOTO   7B6
....................       } 
....................        //---------------------------game over check-----------------------------------------// 
....................        
....................       //---------------------------random Generator-----------------------------------------// 
....................       randPos = 0; 
050F:  CLRF   48
....................       for(int i=0;i<count;i++){ 
0510:  CLRF   4F
0511:  MOVF   4C,W
0512:  SUBWF  4F,W
0513:  BTFSC  03.0
0514:  GOTO   52F
....................          randPos += (freePos[i]*freePos[i])%43; 
0515:  MOVLW  34
0516:  ADDWF  4F,W
0517:  MOVWF  04
0518:  BCF    03.7
0519:  MOVF   00,W
051A:  MOVWF  5B
051B:  MOVLW  34
051C:  ADDWF  4F,W
051D:  MOVWF  04
051E:  BCF    03.7
051F:  MOVF   00,W
0520:  MOVWF  5C
0521:  MOVF   5B,W
0522:  MOVWF  5D
0523:  MOVF   5C,W
0524:  MOVWF  5E
0525:  CALL   2BD
0526:  MOVF   78,W
0527:  MOVWF  63
0528:  MOVLW  2B
0529:  MOVWF  64
052A:  CALL   271
052B:  MOVF   77,W
052C:  ADDWF  48,F
052D:  INCF   4F,F
052E:  GOTO   511
....................       } 
....................       randPos = abs((int)((gen1%41) * randPos))%count; 
052F:  MOVF   44,W
0530:  MOVWF  63
0531:  MOVLW  29
0532:  MOVWF  64
0533:  CALL   271
0534:  MOVF   77,W
0535:  MOVWF  5D
0536:  MOVF   48,W
0537:  MOVWF  5E
0538:  CALL   2BD
0539:  MOVF   78,W
053A:  MOVWF  5B
053B:  MOVF   78,W
053C:  MOVWF  63
053D:  MOVF   4C,W
053E:  MOVWF  64
053F:  CALL   271
0540:  MOVF   77,W
0541:  MOVWF  48
....................       int gen1Tmp = gen1; 
0542:  MOVF   44,W
0543:  MOVWF  50
....................       gen1 = gen2; 
0544:  MOVF   45,W
0545:  MOVWF  44
....................       gen2 = (int)(gen2 * gen1Tmp * randPos); 
0546:  MOVF   45,W
0547:  MOVWF  5D
0548:  MOVF   50,W
0549:  MOVWF  5E
054A:  CALL   2BD
054B:  MOVF   78,W
054C:  MOVWF  5D
054D:  MOVF   48,W
054E:  MOVWF  5E
054F:  CALL   2BD
0550:  MOVF   78,W
0551:  MOVWF  45
....................        
....................       board[freePos[randPos]/n][freePos[randPos]%n] = 2; //fill a new item(number 2) in board. 
0552:  MOVLW  34
0553:  ADDWF  48,W
0554:  MOVWF  04
0555:  BCF    03.7
0556:  RRF    00,W
0557:  MOVWF  77
0558:  RRF    77,F
0559:  MOVLW  3F
055A:  ANDWF  77,F
055B:  MOVF   77,W
055C:  RLF    77,W
055D:  MOVWF  5B
055E:  RLF    5B,F
055F:  MOVLW  FC
0560:  ANDWF  5B,F
0561:  MOVLW  34
0562:  ADDWF  48,W
0563:  MOVWF  04
0564:  BCF    03.7
0565:  MOVF   00,W
0566:  ANDLW  03
0567:  ADDWF  5B,W
0568:  ADDLW  24
0569:  MOVWF  04
056A:  BCF    03.7
056B:  MOVLW  02
056C:  MOVWF  00
....................       //---------------------------random Generator-----------------------------------------// 
....................        
....................       //---------------------------show Board-----------------------------------------// 
....................       for(int i=0;i<n;i++){ 
056D:  CLRF   51
056E:  MOVF   51,W
056F:  SUBLW  03
0570:  BTFSS  03.0
0571:  GOTO   59C
....................          printf("\t"); 
0572:  MOVLW  09
0573:  BTFSS  0C.4
0574:  GOTO   573
0575:  MOVWF  19
....................          for(int j=0;j<n;j++){ 
0576:  CLRF   52
0577:  MOVF   52,W
0578:  SUBLW  03
0579:  BTFSS  03.0
057A:  GOTO   592
....................             printf("\t%d", board[i][j]); 
057B:  RLF    51,W
057C:  MOVWF  77
057D:  RLF    77,F
057E:  MOVLW  FC
057F:  ANDWF  77,F
0580:  MOVF   77,W
0581:  ADDWF  52,W
0582:  ADDLW  24
0583:  MOVWF  04
0584:  BCF    03.7
0585:  MOVF   00,W
0586:  MOVWF  5B
0587:  MOVLW  09
0588:  BTFSS  0C.4
0589:  GOTO   588
058A:  MOVWF  19
058B:  MOVF   5B,W
058C:  MOVWF  5D
058D:  MOVLW  18
058E:  MOVWF  5E
058F:  CALL   2E2
0590:  INCF   52,F
0591:  GOTO   577
....................          } 
....................          printf("\r\n"); 
0592:  MOVLW  0D
0593:  BTFSS  0C.4
0594:  GOTO   593
0595:  MOVWF  19
0596:  MOVLW  0A
0597:  BTFSS  0C.4
0598:  GOTO   597
0599:  MOVWF  19
059A:  INCF   51,F
059B:  GOTO   56E
....................       } 
....................       printf("\t\tadd new [2] in (%d,%d)\r\n",freePos[randPos]/n,freePos[randPos]%n); 
059C:  MOVLW  34
059D:  ADDWF  48,W
059E:  MOVWF  04
059F:  BCF    03.7
05A0:  RRF    00,W
05A1:  MOVWF  5B
05A2:  RRF    5B,F
05A3:  MOVLW  3F
05A4:  ANDWF  5B,F
05A5:  MOVLW  34
05A6:  ADDWF  48,W
05A7:  MOVWF  04
05A8:  BCF    03.7
05A9:  MOVF   00,W
05AA:  ANDLW  03
05AB:  MOVWF  5C
05AC:  MOVLW  3D
05AD:  BSF    03.6
05AE:  MOVWF  0D
05AF:  MOVLW  00
05B0:  MOVWF  0F
05B1:  BCF    03.0
05B2:  MOVLW  12
05B3:  BCF    03.6
05B4:  MOVWF  5D
05B5:  GOTO   33D
05B6:  MOVF   5B,W
05B7:  MOVWF  5D
05B8:  MOVLW  18
05B9:  MOVWF  5E
05BA:  CALL   2E2
05BB:  MOVLW  2C
05BC:  BTFSS  0C.4
05BD:  GOTO   5BC
05BE:  MOVWF  19
05BF:  MOVF   5C,W
05C0:  MOVWF  5D
05C1:  MOVLW  18
05C2:  MOVWF  5E
05C3:  CALL   2E2
05C4:  MOVLW  29
05C5:  BTFSS  0C.4
05C6:  GOTO   5C5
05C7:  MOVWF  19
05C8:  MOVLW  0D
05C9:  BTFSS  0C.4
05CA:  GOTO   5C9
05CB:  MOVWF  19
05CC:  MOVLW  0A
05CD:  BTFSS  0C.4
05CE:  GOTO   5CD
05CF:  MOVWF  19
....................       printf("\r\n"); 
05D0:  MOVLW  0D
05D1:  BTFSS  0C.4
05D2:  GOTO   5D1
05D3:  MOVWF  19
05D4:  MOVLW  0A
05D5:  BTFSS  0C.4
05D6:  GOTO   5D5
05D7:  MOVWF  19
....................       printf("\r\n"); 
05D8:  MOVLW  0D
05D9:  BTFSS  0C.4
05DA:  GOTO   5D9
05DB:  MOVWF  19
05DC:  MOVLW  0A
05DD:  BTFSS  0C.4
05DE:  GOTO   5DD
05DF:  MOVWF  19
....................       //---------------------------show Board-----------------------------------------// 
....................        
....................       //---------------------------get input and move-----------------------------------------// 
....................       keyInput = getc(); 
05E0:  BTFSS  0C.5
05E1:  GOTO   5E0
05E2:  MOVF   1A,W
05E3:  MOVWF  47
....................       switch(keyInput){ 
05E4:  MOVF   47,W
05E5:  XORLW  61
05E6:  BTFSC  03.2
05E7:  GOTO   5F2
05E8:  XORLW  05
05E9:  BTFSC  03.2
05EA:  GOTO   65F
05EB:  XORLW  13
05EC:  BTFSC  03.2
05ED:  GOTO   6D1
05EE:  XORLW  04
05EF:  BTFSC  03.2
05F0:  GOTO   740
05F1:  GOTO   7B5
....................          case 'a': //move items to the left if can. 
....................             printf("\t\t\t----Left----\r\n"); 
05F2:  MOVLW  4B
05F3:  BSF    03.6
05F4:  MOVWF  0D
05F5:  MOVLW  00
05F6:  MOVWF  0F
05F7:  BCF    03.6
05F8:  CALL   182
....................             for(int i=0;i<n;i++){ 
05F9:  CLRF   53
05FA:  MOVF   53,W
05FB:  SUBLW  03
05FC:  BTFSS  03.0
05FD:  GOTO   65E
....................                for(int j=1;j<n;j++){ 
05FE:  MOVLW  01
05FF:  MOVWF  54
0600:  MOVF   54,W
0601:  SUBLW  03
0602:  BTFSS  03.0
0603:  GOTO   65C
....................                   newPos = j; 
0604:  MOVF   54,W
0605:  MOVWF  49
....................                   value = board[i][j]; 
0606:  RLF    53,W
0607:  MOVWF  77
0608:  RLF    77,F
0609:  MOVLW  FC
060A:  ANDWF  77,F
060B:  MOVF   77,W
060C:  ADDWF  54,W
060D:  ADDLW  24
060E:  MOVWF  04
060F:  BCF    03.7
0610:  MOVF   00,W
0611:  MOVWF  4A
....................                   while(newPos > 0){ 
0612:  MOVF   49,F
0613:  BTFSC  03.2
0614:  GOTO   639
....................                      if(board[i][newPos-1] == 0) newPos--; //move when position in left hand empty. 
0615:  RLF    53,W
0616:  MOVWF  5B
0617:  RLF    5B,F
0618:  MOVLW  FC
0619:  ANDWF  5B,F
061A:  MOVLW  01
061B:  SUBWF  49,W
061C:  ADDWF  5B,W
061D:  ADDLW  24
061E:  MOVWF  04
061F:  BCF    03.7
0620:  MOVF   00,F
0621:  BTFSS  03.2
0622:  GOTO   625
0623:  DECF   49,F
0624:  GOTO   638
....................                      else{ 
....................                         if(board[i][newPos-1] == value){ //move when value can sum with same number. 
0625:  RLF    53,W
0626:  MOVWF  5B
0627:  RLF    5B,F
0628:  MOVLW  FC
0629:  ANDWF  5B,F
062A:  MOVLW  01
062B:  SUBWF  49,W
062C:  ADDWF  5B,W
062D:  ADDLW  24
062E:  MOVWF  04
062F:  BCF    03.7
0630:  MOVF   4A,W
0631:  SUBWF  00,W
0632:  BTFSS  03.2
0633:  GOTO   637
....................                            value*=2;  
0634:  BCF    03.0
0635:  RLF    4A,F
....................                            newPos--; 
0636:  DECF   49,F
....................                         } 
....................                         break;//end while loop. 
0637:  GOTO   639
....................                      } 
0638:  GOTO   612
....................                   } 
....................                   if(newPos!=j){ 
0639:  MOVF   54,W
063A:  SUBWF  49,W
063B:  BTFSC  03.2
063C:  GOTO   65A
....................                      if(value > 2) score += value; 
063D:  MOVF   4A,W
063E:  SUBLW  02
063F:  BTFSC  03.0
0640:  GOTO   643
0641:  MOVF   4A,W
0642:  ADDWF  46,F
....................                      board[i][newPos] = value; 
0643:  RLF    53,W
0644:  MOVWF  77
0645:  RLF    77,F
0646:  MOVLW  FC
0647:  ANDWF  77,F
0648:  MOVF   77,W
0649:  ADDWF  49,W
064A:  ADDLW  24
064B:  MOVWF  04
064C:  BCF    03.7
064D:  MOVF   4A,W
064E:  MOVWF  00
....................                      board[i][j] = 0; 
064F:  RLF    53,W
0650:  MOVWF  77
0651:  RLF    77,F
0652:  MOVLW  FC
0653:  ANDWF  77,F
0654:  MOVF   77,W
0655:  ADDWF  54,W
0656:  ADDLW  24
0657:  MOVWF  04
0658:  BCF    03.7
0659:  CLRF   00
....................                   } 
065A:  INCF   54,F
065B:  GOTO   600
....................                } 
065C:  INCF   53,F
065D:  GOTO   5FA
....................             } 
....................              
....................             break; 
065E:  GOTO   7B5
....................          case 'd': //move items to the right if can. 
....................             printf("\t\t\t---Right---\r\n"); 
065F:  MOVLW  54
0660:  BSF    03.6
0661:  MOVWF  0D
0662:  MOVLW  00
0663:  MOVWF  0F
0664:  BCF    03.6
0665:  CALL   182
....................             for(int i=0;i<n;i++){ 
0666:  CLRF   55
0667:  MOVF   55,W
0668:  SUBLW  03
0669:  BTFSS  03.0
066A:  GOTO   6D0
....................                for(int j=1;j<n;j++){ 
066B:  MOVLW  01
066C:  MOVWF  56
066D:  MOVF   56,W
066E:  SUBLW  03
066F:  BTFSS  03.0
0670:  GOTO   6CE
....................                   newPos = n-1-j; 
0671:  MOVF   56,W
0672:  SUBLW  03
0673:  MOVWF  49
....................                   value = board[i][n-1-j]; 
0674:  RLF    55,W
0675:  MOVWF  5B
0676:  RLF    5B,F
0677:  MOVLW  FC
0678:  ANDWF  5B,F
0679:  MOVF   56,W
067A:  SUBLW  03
067B:  ADDWF  5B,W
067C:  ADDLW  24
067D:  MOVWF  04
067E:  BCF    03.7
067F:  MOVF   00,W
0680:  MOVWF  4A
....................                   while(newPos < n-1){ 
0681:  MOVF   49,W
0682:  SUBLW  02
0683:  BTFSS  03.0
0684:  GOTO   6A9
....................                      if(board[i][newPos+1] == 0) newPos++; //move when position in right hand empty. 
0685:  RLF    55,W
0686:  MOVWF  5B
0687:  RLF    5B,F
0688:  MOVLW  FC
0689:  ANDWF  5B,F
068A:  MOVLW  01
068B:  ADDWF  49,W
068C:  ADDWF  5B,W
068D:  ADDLW  24
068E:  MOVWF  04
068F:  BCF    03.7
0690:  MOVF   00,F
0691:  BTFSS  03.2
0692:  GOTO   695
0693:  INCF   49,F
0694:  GOTO   6A8
....................                      else{ 
....................                         if(board[i][newPos+1] == value){ //move when value can sum with same number. 
0695:  RLF    55,W
0696:  MOVWF  5B
0697:  RLF    5B,F
0698:  MOVLW  FC
0699:  ANDWF  5B,F
069A:  MOVLW  01
069B:  ADDWF  49,W
069C:  ADDWF  5B,W
069D:  ADDLW  24
069E:  MOVWF  04
069F:  BCF    03.7
06A0:  MOVF   4A,W
06A1:  SUBWF  00,W
06A2:  BTFSS  03.2
06A3:  GOTO   6A7
....................                            value*=2;  
06A4:  BCF    03.0
06A5:  RLF    4A,F
....................                            newPos++; 
06A6:  INCF   49,F
....................                         } 
....................                         break;//end while loop. 
06A7:  GOTO   6A9
....................                      } 
06A8:  GOTO   681
....................                   } 
....................                   if(newPos!=n-1-j){ 
06A9:  MOVF   56,W
06AA:  SUBLW  03
06AB:  SUBWF  49,W
06AC:  BTFSC  03.2
06AD:  GOTO   6CC
....................                      if(value > 2) score += value; 
06AE:  MOVF   4A,W
06AF:  SUBLW  02
06B0:  BTFSC  03.0
06B1:  GOTO   6B4
06B2:  MOVF   4A,W
06B3:  ADDWF  46,F
....................                      board[i][newPos] = value; 
06B4:  RLF    55,W
06B5:  MOVWF  77
06B6:  RLF    77,F
06B7:  MOVLW  FC
06B8:  ANDWF  77,F
06B9:  MOVF   77,W
06BA:  ADDWF  49,W
06BB:  ADDLW  24
06BC:  MOVWF  04
06BD:  BCF    03.7
06BE:  MOVF   4A,W
06BF:  MOVWF  00
....................                      board[i][n-1-j] = 0; 
06C0:  RLF    55,W
06C1:  MOVWF  5B
06C2:  RLF    5B,F
06C3:  MOVLW  FC
06C4:  ANDWF  5B,F
06C5:  MOVF   56,W
06C6:  SUBLW  03
06C7:  ADDWF  5B,W
06C8:  ADDLW  24
06C9:  MOVWF  04
06CA:  BCF    03.7
06CB:  CLRF   00
....................                   } 
06CC:  INCF   56,F
06CD:  GOTO   66D
....................                } 
06CE:  INCF   55,F
06CF:  GOTO   667
....................             } 
....................             break; 
06D0:  GOTO   7B5
....................          case 'w': //move items to the top if can. 
....................             printf("\t\t\t----Top----\r\n"); 
06D1:  MOVLW  5D
06D2:  BSF    03.6
06D3:  MOVWF  0D
06D4:  MOVLW  00
06D5:  MOVWF  0F
06D6:  BCF    03.6
06D7:  CALL   182
....................             for(int i=0;i<n;i++){ 
06D8:  CLRF   57
06D9:  MOVF   57,W
06DA:  SUBLW  03
06DB:  BTFSS  03.0
06DC:  GOTO   73F
....................                for(int j=1;j<n;j++){ 
06DD:  MOVLW  01
06DE:  MOVWF  58
06DF:  MOVF   58,W
06E0:  SUBLW  03
06E1:  BTFSS  03.0
06E2:  GOTO   73D
....................                   newPos = j; 
06E3:  MOVF   58,W
06E4:  MOVWF  49
....................                   value = board[j][i]; 
06E5:  RLF    58,W
06E6:  MOVWF  77
06E7:  RLF    77,F
06E8:  MOVLW  FC
06E9:  ANDWF  77,F
06EA:  MOVF   77,W
06EB:  ADDWF  57,W
06EC:  ADDLW  24
06ED:  MOVWF  04
06EE:  BCF    03.7
06EF:  MOVF   00,W
06F0:  MOVWF  4A
....................                   while(newPos > 0){ 
06F1:  MOVF   49,F
06F2:  BTFSC  03.2
06F3:  GOTO   71A
....................                      if(board[newPos-1][i] == 0) newPos--; //move when position in top hand empty. 
06F4:  MOVLW  01
06F5:  SUBWF  49,W
06F6:  MOVWF  77
06F7:  RLF    77,F
06F8:  RLF    77,F
06F9:  MOVLW  FC
06FA:  ANDWF  77,F
06FB:  MOVF   77,W
06FC:  ADDWF  57,W
06FD:  ADDLW  24
06FE:  MOVWF  04
06FF:  BCF    03.7
0700:  MOVF   00,F
0701:  BTFSS  03.2
0702:  GOTO   705
0703:  DECF   49,F
0704:  GOTO   719
....................                      else{ 
....................                         if(board[newPos-1][i] == value){ //move when value can sum with same number. 
0705:  MOVLW  01
0706:  SUBWF  49,W
0707:  MOVWF  77
0708:  RLF    77,F
0709:  RLF    77,F
070A:  MOVLW  FC
070B:  ANDWF  77,F
070C:  MOVF   77,W
070D:  ADDWF  57,W
070E:  ADDLW  24
070F:  MOVWF  04
0710:  BCF    03.7
0711:  MOVF   4A,W
0712:  SUBWF  00,W
0713:  BTFSS  03.2
0714:  GOTO   718
....................                            value*=2;  
0715:  BCF    03.0
0716:  RLF    4A,F
....................                            newPos--; 
0717:  DECF   49,F
....................                         } 
....................                         break;//end while loop. 
0718:  GOTO   71A
....................                      } 
0719:  GOTO   6F1
....................                   } 
....................                   if(newPos!=j){ 
071A:  MOVF   58,W
071B:  SUBWF  49,W
071C:  BTFSC  03.2
071D:  GOTO   73B
....................                      if(value > 2) score += value; 
071E:  MOVF   4A,W
071F:  SUBLW  02
0720:  BTFSC  03.0
0721:  GOTO   724
0722:  MOVF   4A,W
0723:  ADDWF  46,F
....................                      board[newPos][i] = value; 
0724:  RLF    49,W
0725:  MOVWF  77
0726:  RLF    77,F
0727:  MOVLW  FC
0728:  ANDWF  77,F
0729:  MOVF   77,W
072A:  ADDWF  57,W
072B:  ADDLW  24
072C:  MOVWF  04
072D:  BCF    03.7
072E:  MOVF   4A,W
072F:  MOVWF  00
....................                      board[j][i] = 0; 
0730:  RLF    58,W
0731:  MOVWF  77
0732:  RLF    77,F
0733:  MOVLW  FC
0734:  ANDWF  77,F
0735:  MOVF   77,W
0736:  ADDWF  57,W
0737:  ADDLW  24
0738:  MOVWF  04
0739:  BCF    03.7
073A:  CLRF   00
....................                   } 
073B:  INCF   58,F
073C:  GOTO   6DF
....................                } 
073D:  INCF   57,F
073E:  GOTO   6D9
....................             } 
....................             break; 
073F:  GOTO   7B5
....................          case 's': //move items to the bottom if can. 
....................             printf("\t\t\t---Bottom---\r\n"); 
0740:  MOVLW  66
0741:  BSF    03.6
0742:  MOVWF  0D
0743:  MOVLW  00
0744:  MOVWF  0F
0745:  BCF    03.6
0746:  CALL   182
....................             for(int i=0;i<n;i++){ 
0747:  CLRF   59
0748:  MOVF   59,W
0749:  SUBLW  03
074A:  BTFSS  03.0
074B:  GOTO   7B5
....................                for(int j=1;j<n;j++){ 
074C:  MOVLW  01
074D:  MOVWF  5A
074E:  MOVF   5A,W
074F:  SUBLW  03
0750:  BTFSS  03.0
0751:  GOTO   7B3
....................                   newPos = n-1-j; 
0752:  MOVF   5A,W
0753:  SUBLW  03
0754:  MOVWF  49
....................                   value = board[n-1-j][i]; 
0755:  MOVF   5A,W
0756:  SUBLW  03
0757:  MOVWF  77
0758:  RLF    77,F
0759:  RLF    77,F
075A:  MOVLW  FC
075B:  ANDWF  77,F
075C:  MOVF   77,W
075D:  ADDWF  59,W
075E:  ADDLW  24
075F:  MOVWF  04
0760:  BCF    03.7
0761:  MOVF   00,W
0762:  MOVWF  4A
....................                   while(newPos < n-1){ 
0763:  MOVF   49,W
0764:  SUBLW  02
0765:  BTFSS  03.0
0766:  GOTO   78D
....................                      if(board[newPos+1][i] == 0) newPos++; //move when position in bottom hand empty. 
0767:  MOVLW  01
0768:  ADDWF  49,W
0769:  MOVWF  77
076A:  RLF    77,F
076B:  RLF    77,F
076C:  MOVLW  FC
076D:  ANDWF  77,F
076E:  MOVF   77,W
076F:  ADDWF  59,W
0770:  ADDLW  24
0771:  MOVWF  04
0772:  BCF    03.7
0773:  MOVF   00,F
0774:  BTFSS  03.2
0775:  GOTO   778
0776:  INCF   49,F
0777:  GOTO   78C
....................                      else{ 
....................                         if(board[newPos+1][i] == value){ //move when value can sum with same number. 
0778:  MOVLW  01
0779:  ADDWF  49,W
077A:  MOVWF  77
077B:  RLF    77,F
077C:  RLF    77,F
077D:  MOVLW  FC
077E:  ANDWF  77,F
077F:  MOVF   77,W
0780:  ADDWF  59,W
0781:  ADDLW  24
0782:  MOVWF  04
0783:  BCF    03.7
0784:  MOVF   4A,W
0785:  SUBWF  00,W
0786:  BTFSS  03.2
0787:  GOTO   78B
....................                            value*=2;  
0788:  BCF    03.0
0789:  RLF    4A,F
....................                            newPos++; 
078A:  INCF   49,F
....................                         } 
....................                         break;//end while loop. 
078B:  GOTO   78D
....................                      } 
078C:  GOTO   763
....................                   } 
....................                   if(newPos!=n-1-j){ 
078D:  MOVF   5A,W
078E:  SUBLW  03
078F:  SUBWF  49,W
0790:  BTFSC  03.2
0791:  GOTO   7B1
....................                      if(value > 2) score += value; 
0792:  MOVF   4A,W
0793:  SUBLW  02
0794:  BTFSC  03.0
0795:  GOTO   798
0796:  MOVF   4A,W
0797:  ADDWF  46,F
....................                      board[newPos][i] = value; 
0798:  RLF    49,W
0799:  MOVWF  77
079A:  RLF    77,F
079B:  MOVLW  FC
079C:  ANDWF  77,F
079D:  MOVF   77,W
079E:  ADDWF  59,W
079F:  ADDLW  24
07A0:  MOVWF  04
07A1:  BCF    03.7
07A2:  MOVF   4A,W
07A3:  MOVWF  00
....................                      board[n-1-j][i] = 0; 
07A4:  MOVF   5A,W
07A5:  SUBLW  03
07A6:  MOVWF  77
07A7:  RLF    77,F
07A8:  RLF    77,F
07A9:  MOVLW  FC
07AA:  ANDWF  77,F
07AB:  MOVF   77,W
07AC:  ADDWF  59,W
07AD:  ADDLW  24
07AE:  MOVWF  04
07AF:  BCF    03.7
07B0:  CLRF   00
....................                   } 
07B1:  INCF   5A,F
07B2:  GOTO   74E
....................                } 
07B3:  INCF   59,F
07B4:  GOTO   748
....................             } 
....................             break;  
....................          default: 
....................       } 
07B5:  GOTO   412
....................       //---------------------------get input and move-----------------------------------------// 
....................        
....................    } 
....................     
.................... } 
07B6:  SLEEP

Configuration Fuses:
   Word  1: 2FC4   INTRC_IO NOWDT PUT NOMCLR NOPROTECT NOCPD BROWNOUT IESO FCMEN NOLVP NODEBUG
   Word  2: 3FFF   BORV40 NOWRT
